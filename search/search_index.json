{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Problem 1: Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation 1.0 Starting from Newton's Second Law Projectile motion can be derived from Newton\u2019s Second Law: \\[ \\vec{F} = m \\vec{a} \\] In the absence of air resistance, the only force acting on the projectile is gravity, acting in the vertical direction: \\[ \\vec{a} = \\begin{bmatrix} 0 \\\\ -g \\end{bmatrix} \\] This leads to the second-order differential equations: Horizontal motion: \\[ \\frac{d^2x}{dt^2} = 0 \\Rightarrow \\frac{dx}{dt} = v_{0x} = v_0 \\cos(\\theta) \\Rightarrow x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion: \\[ \\frac{d^2y}{dt^2} = -g \\Rightarrow \\frac{dy}{dt} = v_0 \\sin(\\theta) - g t \\Rightarrow y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] These equations form the theoretical foundation of projectile motion and will be used to derive further quantities such as the time of flight, range, and trajectory. Projectile motion is a type of two-dimensional motion where an object is launched into the air with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) relative to the horizontal. The motion can be analyzed by breaking it into horizontal (x) and vertical (y) components. 1.1 Equations of Motion The horizontal and vertical components of the initial velocity are: \\[v_{0x} = v_0 \\cos(\\theta)\\] \\[v_{0y} = v_0 \\sin(\\theta)\\] Using the kinematic equations, the motion in each direction is governed by: Horizontal motion (constant velocity, no acceleration in the ideal case): \\[x = v_{0x} t = v_0 \\cos(\\theta) t\\] Vertical motion (accelerated due to gravity): \\[y = v_{0y} t - \\frac{1}{2} g t^2\\] where: \\(g\\) is the acceleration due to gravity \\((9.81 \\text{ m/s}^2)\\) \\(t\\) is the time of flight. 1.2 Time of Flight The time of flight is determined by solving for when the projectile returns to the ground \\((y = 0)\\) : \\( \\(t = \\frac{2 v_0 \\sin(\\theta)}{g}\\) \\) 1.3 Range Equation The range \\( \\(R\\) \\) is the horizontal distance traveled when the projectile lands: \\( \\(R = v_{0x} \\cdot t = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) \\) Using the identity \\( \\(2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) \\) , we get: \\( \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) \\) 2. Analysis of the Range The range is maximized when \\( \\(\\sin(2\\theta) = 1\\) \\) , which occurs at \\( \\(2\\theta = 90^\\circ\\) \\) , or \\( \\(\\theta = 45^\\circ\\) \\) . If the initial velocity \\( \\(v_0\\) \\) increases, the range increases quadratically. If gravity \\( \\(g\\) \\) increases (e.g., on another planet), the range decreases. 3. Practical Applications Sports: Understanding projectile motion is crucial in games like soccer, basketball, and golf. Engineering: Used in ballistics, rocketry, and artillery targeting systems. Real-World Effects: Air resistance, wind, and uneven terrain can significantly alter the theoretical range. 4. Implementation: Python Simulation The following Python script simulates projectile motion and plots the range as a function of the angle of projection. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0=20, g=9.81): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') max_range = (v0**2 * np.sin(np.radians(90))) / g plt.plot(45, max_range, 'ro') plt.annotate(f'Max: {max_range:.1f} m', xy=(45, max_range), xytext=(50, max_range + 5), arrowprops=dict(arrowstyle=\"->\")) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle (v\u2080 = 20 m/s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() projectile_range() Figure 1: Horizontal range vs. launch angle for a projectile with v\u2080 = 20 m/s. Maximum range occurs at 45\u00b0. Explanation of the Graph This graph illustrates how the horizontal range of a projectile depends on the launch angle for different initial velocities ( \\( v_0 \\) ). Each curve represents a different initial velocity. The maximum range occurs at 45\u00b0 . As the initial velocity increases, the range increases quadratically ( \\( v_0^2 \\) ) . Lower initial velocities result in shorter ranges, while higher velocities allow the projectile to travel further. This helps in understanding how objects like balls, bullets, or rockets behave when launched at different speeds and angles. \ud83d\ude80 import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_v0(v0_list, g=9.81): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) plt.figure(figsize=(8, 5)) for v0 in v0_list: ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') max_range = (v0**2 * np.sin(np.radians(90))) / g plt.plot(45, max_range, 'o') # Nokta koy plt.annotate(f'{max_range:.1f} m', xy=(45, max_range), xytext=(45, max_range + 2), fontsize=8) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different v\u2080\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() projectile_range_multi_v0([10, 20, 30, 40]) Figure 2: Horizontal range vs. launch angle for different initial velocities. Higher v\u2080 increases the range, and the maximum always occurs at 45\u00b0. Explanation of the Graph This graph shows how the horizontal range of a projectile changes with the launch angle for different gravitational accelerations ( \\(g\\) ). Each curve represents a different gravitational environment: Earth ( \\(g = 9.81 \\, \\text{m/s}^2\\) ), Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), and Jupiter ( \\(g = 24.79 \\, \\text{m/s}^2\\) ). As gravity decreases (like on the Moon), the range increases for the same initial velocity. On higher gravity bodies (like Jupiter), the range decreases. This graph helps understand how the same projectile behaves differently in various planetary environments. import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_g(v0=20, g_values=[9.81, 1.62, 24.79]): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) g_labels = [\"Earth (9.81 m/s\u00b2)\", \"Moon (1.62 m/s\u00b2)\", \"Jupiter (24.79 m/s\u00b2)\"] plt.figure(figsize=(8, 5)) for g, label in zip(g_values, g_labels): ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=label) max_range = (v0**2 * np.sin(np.radians(90))) / g plt.plot(45, max_range, 'o') plt.annotate(f'{max_range:.1f} m', xy=(45, max_range), xytext=(45, max_range + 2), fontsize=8) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different Gravities\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() projectile_range_multi_g() Figure 3: Horizontal range vs. launch angle under different gravitational accelerations. Lower gravity leads to longer ranges; maximum always at 45\u00b0. Explanation of the Graph This graph demonstrates how the initial height ( \\(y_0\\) ) affects the projectile's motion. Each curve represents a projectile launched from a different height. The higher the starting point, the longer the projectile stays in the air. Longer airtime results in a greater horizontal range . This effect is especially noticeable when launching from elevated positions (e.g., a cliff, a tower). This concept is useful in real-world scenarios like launching missiles from elevated platforms or analyzing sports trajectories like basketball shots from different angles. \ud83c\udfc0 import numpy as np import matplotlib.pyplot as plt def trajectory(v0, angle_deg, y0=0, g=9.81): angle_rad = np.radians(angle_deg) vy0 = v0 * np.sin(angle_rad) t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g t = np.linspace(0, t_flight, 500) x = v0 * np.cos(angle_rad) * t y = y0 + vy0 * t - 0.5 * g * t**2 return x, y v0 = 25 angle = 45 heights = [0, 10, 50] plt.figure(figsize=(10, 6)) for h in heights: x, y = trajectory(v0, angle, y0=h) plt.plot(x, y, label=f'Initial height = {h} m') plt.title(\"Projectile Motion from Different Heights (v\u2080 = 25 m/s, \u03b8 = 45\u00b0)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Figure 4: Trajectories of projectiles launched from different heights (0 m, 10 m, 50 m) at 45\u00b0 and 25 m/s. Explanation of the Graph This graph compares projectile motion with and without air resistance . The red curve shows the ideal case (no air resistance). The blue dashed curve includes air resistance. With air resistance, the projectile does not travel as far and has a flatter arc . The effect of air resistance becomes more noticeable at higher speeds. This comparison is essential in real-world applications like ballistics, sports, and aerospace engineering, where air drag cannot be ignored. \u2708\ufe0f import numpy as np import matplotlib.pyplot as plt def trajectory(v0, angle_deg, y0=0, g=9.81): angle_rad = np.radians(angle_deg) vy0 = v0 * np.sin(angle_rad) t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g t = np.linspace(0, t_flight, 500) x = v0 * np.cos(angle_rad) * t y = y0 + vy0 * t - 0.5 * g * t**2 return x, y def trajectory_with_air_resistance(v0, angle_deg, y0=0, g=9.81, k=0.05, dt=0.01): angle_rad = np.radians(angle_deg) vx = v0 * np.cos(angle_rad) vy = v0 * np.sin(angle_rad) x, y = 0, y0 X, Y = [x], [y] while y >= 0: ax = -k * vx ay = -g - k * vy vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt X.append(x) Y.append(y) return X, Y v0 = 25 angle = 45 x1, y1 = trajectory(v0, angle) x2, y2 = trajectory_with_air_resistance(v0, angle) plt.figure(figsize=(10, 6)) plt.plot(x1, y1, label='No Air Resistance', color='red') plt.plot(x2, y2, '--', label='With Air Resistance', color='blue') plt.title(\"Projectile Motion: With vs. Without Air Resistance (v\u2080 = 25 m/s, \u03b8 = 45\u00b0)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() Figure 5: Comparison of trajectories with and without air resistance. \ud83c\udfaf Trajectory Comparison for Different Launch Angles (v\u2080 = 25 m/s) This graph shows how the launch angle affects the trajectory shape and horizontal distance when the initial velocity is fixed at 25 m/s. All projectiles are launched from the same height and speed. Angles used: 15\u00b0, 39\u00b0, 45\u00b0, and 60\u00b0 The longest range is achieved at 45\u00b0 . Higher angles result in higher but shorter trajectories. import numpy as np import matplotlib.pyplot as plt def trajectory(v0, angle_deg, y0=0, g=9.81): angle_rad = np.radians(angle_deg) vy0 = v0 * np.sin(angle_rad) t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g t = np.linspace(0, t_flight, 500) x = v0 * np.cos(angle_rad) * t y = y0 + vy0 * t - 0.5 * g * t**2 return x, y # Parameters v0 = 25 angles = [15, 39, 45, 60] plt.figure(figsize=(10, 6)) for angle in angles: x, y = trajectory(v0, angle) plt.plot(x, y, label=f'{angle}\u00b0') plt.title(\"Projectile Trajectories at Different Angles (v\u2080 = 25 m/s)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Figure 6: Trajectories for different launch angles at fixed speed (v\u2080 = 25 m/s). 5. Frequently Asked Questions (FAQ) 1. At what angle is the maximum range achieved in projectile motion? The maximum range is achieved at 45\u00b0 because, at this angle, the horizontal and vertical components of the velocity are balanced, maximizing distance. 2. How does the initial velocity affect the range? The range increases quadratically (v\u2080\u00b2) as the initial velocity increases, meaning a faster launch gives the projectile more distance to travel. 3. What happens if gravity changes? A higher gravitational acceleration reduces the range because the projectile falls back to the ground more quickly, while a lower gravity increases the range by allowing the projectile to stay in the air longer. 4. Does mass affect the projectile's range? No, in ideal conditions without air resistance, mass does not affect the range because both heavy and light projectiles fall at the same rate under the same conditions. 5. How does air resistance impact projectile motion? Air resistance reduces the range by slowing down the projectile and changing its trajectory, making the optimal launch angle lower than 45\u00b0. \u2705 Checklist: Teacher's Suggestions Implemented Suggestion Status Location in Project 3 different velocities (v\u2080) at same angle, showing range comparison \u2714\ufe0f Done Figure 2 \u2013 projectile_range_multi_v0 3 different planets (different gravity values) with same initial velocity \u2714\ufe0f Done Figure 3 \u2013 projectile_range_multi_g Launching from different heights \u2714\ufe0f Done Figure 4 \u2013 heights = [0, 10, 50] Same speed with different angles (15\u00b0, 39\u00b0, 45\u00b0, 60\u00b0) \u2714\ufe0f Done Figure 6 \u2013 angles = [15, 39, 45, 60] Comparison between with and without air resistance \u2714\ufe0f Done Figure 5 \u2013 trajectory_with_air_resistance()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#10-starting-from-newtons-second-law","text":"Projectile motion can be derived from Newton\u2019s Second Law: \\[ \\vec{F} = m \\vec{a} \\] In the absence of air resistance, the only force acting on the projectile is gravity, acting in the vertical direction: \\[ \\vec{a} = \\begin{bmatrix} 0 \\\\ -g \\end{bmatrix} \\] This leads to the second-order differential equations: Horizontal motion: \\[ \\frac{d^2x}{dt^2} = 0 \\Rightarrow \\frac{dx}{dt} = v_{0x} = v_0 \\cos(\\theta) \\Rightarrow x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion: \\[ \\frac{d^2y}{dt^2} = -g \\Rightarrow \\frac{dy}{dt} = v_0 \\sin(\\theta) - g t \\Rightarrow y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] These equations form the theoretical foundation of projectile motion and will be used to derive further quantities such as the time of flight, range, and trajectory. Projectile motion is a type of two-dimensional motion where an object is launched into the air with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) relative to the horizontal. The motion can be analyzed by breaking it into horizontal (x) and vertical (y) components.","title":"1.0 Starting from Newton's Second Law"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion","text":"The horizontal and vertical components of the initial velocity are: \\[v_{0x} = v_0 \\cos(\\theta)\\] \\[v_{0y} = v_0 \\sin(\\theta)\\] Using the kinematic equations, the motion in each direction is governed by: Horizontal motion (constant velocity, no acceleration in the ideal case): \\[x = v_{0x} t = v_0 \\cos(\\theta) t\\] Vertical motion (accelerated due to gravity): \\[y = v_{0y} t - \\frac{1}{2} g t^2\\] where: \\(g\\) is the acceleration due to gravity \\((9.81 \\text{ m/s}^2)\\) \\(t\\) is the time of flight.","title":"1.1 Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"The time of flight is determined by solving for when the projectile returns to the ground \\((y = 0)\\) : \\( \\(t = \\frac{2 v_0 \\sin(\\theta)}{g}\\) \\)","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range-equation","text":"The range \\( \\(R\\) \\) is the horizontal distance traveled when the projectile lands: \\( \\(R = v_{0x} \\cdot t = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) \\) Using the identity \\( \\(2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) \\) , we get: \\( \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) \\)","title":"1.3 Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range is maximized when \\( \\(\\sin(2\\theta) = 1\\) \\) , which occurs at \\( \\(2\\theta = 90^\\circ\\) \\) , or \\( \\(\\theta = 45^\\circ\\) \\) . If the initial velocity \\( \\(v_0\\) \\) increases, the range increases quadratically. If gravity \\( \\(g\\) \\) increases (e.g., on another planet), the range decreases.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports: Understanding projectile motion is crucial in games like soccer, basketball, and golf. Engineering: Used in ballistics, rocketry, and artillery targeting systems. Real-World Effects: Air resistance, wind, and uneven terrain can significantly alter the theoretical range.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation","text":"The following Python script simulates projectile motion and plots the range as a function of the angle of projection. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0=20, g=9.81): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') max_range = (v0**2 * np.sin(np.radians(90))) / g plt.plot(45, max_range, 'ro') plt.annotate(f'Max: {max_range:.1f} m', xy=(45, max_range), xytext=(50, max_range + 5), arrowprops=dict(arrowstyle=\"->\")) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle (v\u2080 = 20 m/s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() projectile_range() Figure 1: Horizontal range vs. launch angle for a projectile with v\u2080 = 20 m/s. Maximum range occurs at 45\u00b0.","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-graph","text":"This graph illustrates how the horizontal range of a projectile depends on the launch angle for different initial velocities ( \\( v_0 \\) ). Each curve represents a different initial velocity. The maximum range occurs at 45\u00b0 . As the initial velocity increases, the range increases quadratically ( \\( v_0^2 \\) ) . Lower initial velocities result in shorter ranges, while higher velocities allow the projectile to travel further. This helps in understanding how objects like balls, bullets, or rockets behave when launched at different speeds and angles. \ud83d\ude80 import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_v0(v0_list, g=9.81): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) plt.figure(figsize=(8, 5)) for v0 in v0_list: ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') max_range = (v0**2 * np.sin(np.radians(90))) / g plt.plot(45, max_range, 'o') # Nokta koy plt.annotate(f'{max_range:.1f} m', xy=(45, max_range), xytext=(45, max_range + 2), fontsize=8) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different v\u2080\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() projectile_range_multi_v0([10, 20, 30, 40]) Figure 2: Horizontal range vs. launch angle for different initial velocities. Higher v\u2080 increases the range, and the maximum always occurs at 45\u00b0.","title":"Explanation of the Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-graph_1","text":"This graph shows how the horizontal range of a projectile changes with the launch angle for different gravitational accelerations ( \\(g\\) ). Each curve represents a different gravitational environment: Earth ( \\(g = 9.81 \\, \\text{m/s}^2\\) ), Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), and Jupiter ( \\(g = 24.79 \\, \\text{m/s}^2\\) ). As gravity decreases (like on the Moon), the range increases for the same initial velocity. On higher gravity bodies (like Jupiter), the range decreases. This graph helps understand how the same projectile behaves differently in various planetary environments. import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_g(v0=20, g_values=[9.81, 1.62, 24.79]): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) g_labels = [\"Earth (9.81 m/s\u00b2)\", \"Moon (1.62 m/s\u00b2)\", \"Jupiter (24.79 m/s\u00b2)\"] plt.figure(figsize=(8, 5)) for g, label in zip(g_values, g_labels): ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=label) max_range = (v0**2 * np.sin(np.radians(90))) / g plt.plot(45, max_range, 'o') plt.annotate(f'{max_range:.1f} m', xy=(45, max_range), xytext=(45, max_range + 2), fontsize=8) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different Gravities\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() projectile_range_multi_g() Figure 3: Horizontal range vs. launch angle under different gravitational accelerations. Lower gravity leads to longer ranges; maximum always at 45\u00b0.","title":"Explanation of the Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-graph_2","text":"This graph demonstrates how the initial height ( \\(y_0\\) ) affects the projectile's motion. Each curve represents a projectile launched from a different height. The higher the starting point, the longer the projectile stays in the air. Longer airtime results in a greater horizontal range . This effect is especially noticeable when launching from elevated positions (e.g., a cliff, a tower). This concept is useful in real-world scenarios like launching missiles from elevated platforms or analyzing sports trajectories like basketball shots from different angles. \ud83c\udfc0 import numpy as np import matplotlib.pyplot as plt def trajectory(v0, angle_deg, y0=0, g=9.81): angle_rad = np.radians(angle_deg) vy0 = v0 * np.sin(angle_rad) t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g t = np.linspace(0, t_flight, 500) x = v0 * np.cos(angle_rad) * t y = y0 + vy0 * t - 0.5 * g * t**2 return x, y v0 = 25 angle = 45 heights = [0, 10, 50] plt.figure(figsize=(10, 6)) for h in heights: x, y = trajectory(v0, angle, y0=h) plt.plot(x, y, label=f'Initial height = {h} m') plt.title(\"Projectile Motion from Different Heights (v\u2080 = 25 m/s, \u03b8 = 45\u00b0)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Figure 4: Trajectories of projectiles launched from different heights (0 m, 10 m, 50 m) at 45\u00b0 and 25 m/s.","title":"Explanation of the Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-graph_3","text":"This graph compares projectile motion with and without air resistance . The red curve shows the ideal case (no air resistance). The blue dashed curve includes air resistance. With air resistance, the projectile does not travel as far and has a flatter arc . The effect of air resistance becomes more noticeable at higher speeds. This comparison is essential in real-world applications like ballistics, sports, and aerospace engineering, where air drag cannot be ignored. \u2708\ufe0f import numpy as np import matplotlib.pyplot as plt def trajectory(v0, angle_deg, y0=0, g=9.81): angle_rad = np.radians(angle_deg) vy0 = v0 * np.sin(angle_rad) t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g t = np.linspace(0, t_flight, 500) x = v0 * np.cos(angle_rad) * t y = y0 + vy0 * t - 0.5 * g * t**2 return x, y def trajectory_with_air_resistance(v0, angle_deg, y0=0, g=9.81, k=0.05, dt=0.01): angle_rad = np.radians(angle_deg) vx = v0 * np.cos(angle_rad) vy = v0 * np.sin(angle_rad) x, y = 0, y0 X, Y = [x], [y] while y >= 0: ax = -k * vx ay = -g - k * vy vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt X.append(x) Y.append(y) return X, Y v0 = 25 angle = 45 x1, y1 = trajectory(v0, angle) x2, y2 = trajectory_with_air_resistance(v0, angle) plt.figure(figsize=(10, 6)) plt.plot(x1, y1, label='No Air Resistance', color='red') plt.plot(x2, y2, '--', label='With Air Resistance', color='blue') plt.title(\"Projectile Motion: With vs. Without Air Resistance (v\u2080 = 25 m/s, \u03b8 = 45\u00b0)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() Figure 5: Comparison of trajectories with and without air resistance.","title":"Explanation of the Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#trajectory-comparison-for-different-launch-angles-v0-25-ms","text":"This graph shows how the launch angle affects the trajectory shape and horizontal distance when the initial velocity is fixed at 25 m/s. All projectiles are launched from the same height and speed. Angles used: 15\u00b0, 39\u00b0, 45\u00b0, and 60\u00b0 The longest range is achieved at 45\u00b0 . Higher angles result in higher but shorter trajectories. import numpy as np import matplotlib.pyplot as plt def trajectory(v0, angle_deg, y0=0, g=9.81): angle_rad = np.radians(angle_deg) vy0 = v0 * np.sin(angle_rad) t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g t = np.linspace(0, t_flight, 500) x = v0 * np.cos(angle_rad) * t y = y0 + vy0 * t - 0.5 * g * t**2 return x, y # Parameters v0 = 25 angles = [15, 39, 45, 60] plt.figure(figsize=(10, 6)) for angle in angles: x, y = trajectory(v0, angle) plt.plot(x, y, label=f'{angle}\u00b0') plt.title(\"Projectile Trajectories at Different Angles (v\u2080 = 25 m/s)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Figure 6: Trajectories for different launch angles at fixed speed (v\u2080 = 25 m/s).","title":"\ud83c\udfaf Trajectory Comparison for Different Launch Angles (v\u2080 = 25 m/s)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-frequently-asked-questions-faq","text":"","title":"5. Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-at-what-angle-is-the-maximum-range-achieved-in-projectile-motion","text":"The maximum range is achieved at 45\u00b0 because, at this angle, the horizontal and vertical components of the velocity are balanced, maximizing distance.","title":"1. At what angle is the maximum range achieved in projectile motion?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-how-does-the-initial-velocity-affect-the-range","text":"The range increases quadratically (v\u2080\u00b2) as the initial velocity increases, meaning a faster launch gives the projectile more distance to travel.","title":"2. How does the initial velocity affect the range?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-what-happens-if-gravity-changes","text":"A higher gravitational acceleration reduces the range because the projectile falls back to the ground more quickly, while a lower gravity increases the range by allowing the projectile to stay in the air longer.","title":"3. What happens if gravity changes?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-does-mass-affect-the-projectiles-range","text":"No, in ideal conditions without air resistance, mass does not affect the range because both heavy and light projectiles fall at the same rate under the same conditions.","title":"4. Does mass affect the projectile's range?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-how-does-air-resistance-impact-projectile-motion","text":"Air resistance reduces the range by slowing down the projectile and changing its trajectory, making the optimal launch angle lower than 45\u00b0.","title":"5. How does air resistance impact projectile motion?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#checklist-teachers-suggestions-implemented","text":"Suggestion Status Location in Project 3 different velocities (v\u2080) at same angle, showing range comparison \u2714\ufe0f Done Figure 2 \u2013 projectile_range_multi_v0 3 different planets (different gravity values) with same initial velocity \u2714\ufe0f Done Figure 3 \u2013 projectile_range_multi_g Launching from different heights \u2714\ufe0f Done Figure 4 \u2013 heights = [0, 10, 50] Same speed with different angles (15\u00b0, 39\u00b0, 45\u00b0, 60\u00b0) \u2714\ufe0f Done Figure 6 \u2013 angles = [15, 39, 45, 60] Comparison between with and without air resistance \u2714\ufe0f Done Figure 5 \u2013 trajectory_with_air_resistance()","title":"\u2705 Checklist: Teacher's Suggestions Implemented"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a classic example of nonlinear dynamics. Unlike simple harmonic oscillators, this system responds to periodic external forces and damping, producing rich behavior that includes resonance, synchronization, and even chaos. This kind of system is fundamental in physics and engineering because it mirrors the behavior of real-world systems like suspension bridges, circuits, and mechanical vibration absorbers. 1. Theoretical Foundation The general nonlinear equation for the forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement (radians) - \\(\\gamma\\) : damping coefficient (how quickly oscillations die out) - \\(\\omega_0\\) : natural angular frequency ( \\(\\omega_0 = \\sqrt{g / L}\\) for a pendulum of length \\(L\\) ) - \\(A\\) : amplitude of external force - \\(\\omega\\) : driving frequency Small-Angle Approximation When \\(\\theta\\) is small (typically less than 10\u00b0), we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This form is a linear second-order ODE, easier to solve and useful for studying resonance behavior. 2. Python Simulation Let's simulate the pendulum using numerical methods. We'll use the Runge-Kutta method via scipy.integrate.solve_ivp . import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Differential equation def pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dydt = [omega_theta, -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Parameters gamma = 0.2 omega0 = 1.5 A = 1.2 omega_drive = 2.0 y0 = [0.1, 0.0] t_span = (0, 50) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) # Plot angle over time plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.grid(True) plt.legend() plt.show() 3. Phase Space (\u03b8 vs \u03c9) This plot helps visualize how the system evolves in state space. plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Space') plt.xlabel('Angle \u03b8 (rad)') plt.ylabel('Angular Velocity \u03c9 (rad/s)') plt.grid(True) plt.show() 4. Poincar\u00e9 Section The Poincar\u00e9 section samples the system once per driving cycle, helping identify periodicity and chaos. T = 2 * np.pi / omega_drive poincare_times = np.arange(0, t_span[1], T) poincare_points = [] for t_p in poincare_times: idx = np.argmin(np.abs(sol.t - t_p)) poincare_points.append([sol.y[0][idx] % (2*np.pi), sol.y[1][idx]]) poincare_points = np.array(poincare_points) plt.figure(figsize=(6, 6)) plt.scatter(poincare_points[:, 0], poincare_points[:, 1], s=10, color='crimson') plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 mod $2\\pi$ (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.grid(True) plt.show() 5. Additional Visualization: Energy Over Time Visualizing total mechanical energy shows how damping and driving force interact. mass = 1.0 length = 1.0 g = 9.81 theta = sol.y[0] omega = sol.y[1] potential_energy = mass * g * length * (1 - np.cos(theta)) kinetic_energy = 0.5 * mass * (length**2) * omega**2 total_energy = potential_energy + kinetic_energy plt.figure(figsize=(10, 4)) plt.plot(sol.t, total_energy) plt.title('Total Mechanical Energy vs Time') plt.xlabel('Time (s)') plt.ylabel('Energy (J)') plt.grid(True) plt.show() 6. Bifurcation Diagram Explore how the long-term behavior changes with the driving amplitude A. bifurcation_A = np.linspace(1.0, 1.5, 300) steady_states = [] for A_val in bifurcation_A: sol = solve_ivp(pendulum, [0, 200], [0.1, 0.0], t_eval=np.linspace(150, 200, 500), args=(gamma, omega0, A_val, omega_drive)) theta_vals = sol.y[0] % (2 * np.pi) steady_states.append((np.full_like(theta_vals, A_val), theta_vals)) plt.figure(figsize=(10, 6)) for A_vals, thetas in steady_states: plt.plot(A_vals, thetas, ',k', alpha=0.5) plt.title(\"Bifurcation Diagram (A vs \u03b8)\") plt.xlabel(\"Driving Amplitude A\") plt.ylabel(\"\u03b8 mod 2\u03c0\") plt.grid(True) plt.show() 7. Lyapunov Exponent Estimation Estimate the largest Lyapunov exponent to determine chaos. def estimate_lyapunov(delta0=1e-8, T_max=100): y1 = np.array([0.1, 0.0]) y2 = y1 + np.array([delta0, 0]) times = np.linspace(0, T_max, 10000) d_list = [] for t in range(len(times) - 1): sol1 = solve_ivp(pendulum, [times[t], times[t+1]], y1, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) sol2 = solve_ivp(pendulum, [times[t], times[t+1]], y2, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) y1 = sol1.y[:, -1] y2 = sol2.y[:, -1] delta = np.linalg.norm(y2 - y1) d_list.append(np.log(delta / delta0)) y2 = y1 + delta0 * (y2 - y1) / delta # Renormalize return times[1:], np.cumsum(d_list) / np.arange(1, len(d_list)+1) ltimes, lyap = estimate_lyapunov() plt.figure(figsize=(8, 4)) plt.plot(ltimes, lyap) plt.title(\"Estimated Largest Lyapunov Exponent\") plt.xlabel(\"Time\") plt.ylabel(\"Lyapunov Exponent\") plt.grid(True) plt.show() 8. Exploring Parameters Experimenting with parameters leads to different behaviors: - Increasing A may cause chaotic motion. - Lowering \u03b3 shows less damping, leading to longer sustained oscillations. - Matching \u03c9 with \u03c9\u2080 creates resonance, producing large amplitudes. \ud83d\udd04 Extended Visualization: Adding Forced but Undamped Pendulum This scenario demonstrates periodic motion with sustained energy input and no damping, resulting in regular oscillations without energy loss \u2014 a resonance-friendly setup. We now add the fourth scenario that was previously missing: Case Damping ( \\(b\\) ) Forcing ( \\(A\\) ) Simple Pendulum 0 0 Damped Pendulum 0.5 0 Forced Damped Pendulum 0.5 1.2 Forced (Undamped) Pendulum 0 1.2 \u2705 NEW This configuration shows how the system behaves when it's driven but has no energy loss \u2013 a potentially resonant and unstable regime. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] gamma_forced_undamped = 0.0 A_forced = 1.2 omega_drive = 2.0 sol_forced_undamped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(gamma_forced_undamped, A_forced, omega_drive)) plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol_forced_undamped.t, sol_forced_undamped.y[0]) plt.title(\"Forced (Undamped) Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(1, 2, 2) plt.plot(sol_forced_undamped.y[0], sol_forced_undamped.y[1]) plt.title(\"Forced (Undamped) Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show() 9. Real-World Applications Energy Harvesters : Pendulums can convert motion into usable energy. Bridge Engineering : Avoiding resonance in suspension bridges is crucial. Washing Machines : Proper damping reduces imbalance. Electronics : RLC circuits have similar equations. Clocks : Pendulum clocks are based on resonance principles. 10. Model Limitations and Extensions The model assumes ideal sine driving forces. Real-world damping is often nonlinear. It doesn't account for multi-dimensional motion. Possible Extensions Add random or non-periodic forcing. Add nonlinear damping (quadratic drag). Study bifurcation diagrams over varying A or \u03c9. Simulate coupled or double pendulums. FAQ - Common Questions 1. What makes the forced damped pendulum nonlinear? The presence of the \\(\\sin\\theta\\) term (instead of \\(\\theta\\) ) introduces nonlinearity, which makes the system exhibit complex dynamics such as chaos. 2. Why is damping important in the system? Damping removes energy from the system. Without it, the pendulum would keep oscillating forever if externally driven. 3. What happens at resonance? When the driving frequency matches the natural frequency ( \\(\\omega \\approx \\omega_0\\) ), the system absorbs maximum energy, causing large oscillations. 4. Why do we use the small-angle approximation? It simplifies the math by making the equation linear. It\u2019s only valid for small displacements (typically \\(\\theta < 10^{\\circ}\\) ). 5. What is a Poincar\u00e9 section and why is it useful? It\u2019s a snapshot of the system at regular intervals. It helps identify periodic vs chaotic behavior in a simpler 2D plot. 6. Can this system become chaotic? Yes. With certain combinations of damping, amplitude, and driving frequency, the system becomes highly sensitive to initial conditions and unpredictable. 7. What are real-world analogs of this system? Any system with damping and periodic forcing\u2014like RLC circuits, mechanical oscillators, or climate systems\u2014can be modeled similarly. Feel free to change the parameters and explore how simple rules can create unpredictable patterns. To fully illustrate the transition from simple to complex dynamics, we add simulations for: Simple Pendulum (no damping, no forcing) Damped Pendulum (with damping, no forcing) Forced Damped Pendulum (already shown above) We simulate and visualize angle-time plots and phase diagrams for the first two to complete the progression. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] sol_simple = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.0, 0.0, 0.0)) sol_damped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.5, 0.0, 0.0)) plt.figure(figsize=(14, 10)) plt.subplot(2, 2, 1) plt.plot(sol_simple.t, sol_simple.y[0]) plt.title(\"Simple Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 2) plt.plot(sol_simple.y[0], sol_simple.y[1]) plt.title(\"Simple Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.subplot(2, 2, 3) plt.plot(sol_damped.t, sol_damped.y[0]) plt.title(\"Damped Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 4) plt.plot(sol_damped.y[0], sol_damped.y[1]) plt.title(\"Damped Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show() Appendix: Completion Checklist Category Content Description Included? Theoretical Foundation Differential equation, small-angle approximation, and resonance explanation \u2705 Yes Python Simulation Time-domain simulation using solve_ivp and parameter configuration \u2705 Yes Phase Space Plot Visualization of the angular velocity vs angle (\u03b8 vs \u03c9) \u2705 Yes Poincar\u00e9 Section Stroboscopic mapping to visualize periodic vs chaotic behavior \u2705 Yes Energy Analysis Plot showing kinetic + potential energy over time \u2705 Yes Bifurcation Diagram Diagram showing system behavior vs driving amplitude (A) \u2705 Yes Lyapunov Exponent Numerical estimation of chaos via divergence of nearby trajectories \u2705 Yes Parameter Exploration Discussion of how \u03b3, A, and \u03c9 affect the dynamics \u2705 Yes Real-World Applications Analogies to bridges, electronics, and mechanical systems \u2705 Yes Model Limitations Discussion of assumptions and suggestions for extensions \u2705 Yes FAQ Section Seven clear and relevant conceptual questions with explanations \u2705 Yes","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a classic example of nonlinear dynamics. Unlike simple harmonic oscillators, this system responds to periodic external forces and damping, producing rich behavior that includes resonance, synchronization, and even chaos. This kind of system is fundamental in physics and engineering because it mirrors the behavior of real-world systems like suspension bridges, circuits, and mechanical vibration absorbers.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The general nonlinear equation for the forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement (radians) - \\(\\gamma\\) : damping coefficient (how quickly oscillations die out) - \\(\\omega_0\\) : natural angular frequency ( \\(\\omega_0 = \\sqrt{g / L}\\) for a pendulum of length \\(L\\) ) - \\(A\\) : amplitude of external force - \\(\\omega\\) : driving frequency","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"When \\(\\theta\\) is small (typically less than 10\u00b0), we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This form is a linear second-order ODE, easier to solve and useful for studying resonance behavior.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-python-simulation","text":"Let's simulate the pendulum using numerical methods. We'll use the Runge-Kutta method via scipy.integrate.solve_ivp . import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Differential equation def pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dydt = [omega_theta, -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Parameters gamma = 0.2 omega0 = 1.5 A = 1.2 omega_drive = 2.0 y0 = [0.1, 0.0] t_span = (0, 50) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) # Plot angle over time plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.grid(True) plt.legend() plt.show()","title":"2. Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-phase-space-vs","text":"This plot helps visualize how the system evolves in state space. plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Space') plt.xlabel('Angle \u03b8 (rad)') plt.ylabel('Angular Velocity \u03c9 (rad/s)') plt.grid(True) plt.show()","title":"3. Phase Space (\u03b8 vs \u03c9)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-poincare-section","text":"The Poincar\u00e9 section samples the system once per driving cycle, helping identify periodicity and chaos. T = 2 * np.pi / omega_drive poincare_times = np.arange(0, t_span[1], T) poincare_points = [] for t_p in poincare_times: idx = np.argmin(np.abs(sol.t - t_p)) poincare_points.append([sol.y[0][idx] % (2*np.pi), sol.y[1][idx]]) poincare_points = np.array(poincare_points) plt.figure(figsize=(6, 6)) plt.scatter(poincare_points[:, 0], poincare_points[:, 1], s=10, color='crimson') plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 mod $2\\pi$ (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.grid(True) plt.show()","title":"4. Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-additional-visualization-energy-over-time","text":"Visualizing total mechanical energy shows how damping and driving force interact. mass = 1.0 length = 1.0 g = 9.81 theta = sol.y[0] omega = sol.y[1] potential_energy = mass * g * length * (1 - np.cos(theta)) kinetic_energy = 0.5 * mass * (length**2) * omega**2 total_energy = potential_energy + kinetic_energy plt.figure(figsize=(10, 4)) plt.plot(sol.t, total_energy) plt.title('Total Mechanical Energy vs Time') plt.xlabel('Time (s)') plt.ylabel('Energy (J)') plt.grid(True) plt.show()","title":"5. Additional Visualization: Energy Over Time"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-bifurcation-diagram","text":"Explore how the long-term behavior changes with the driving amplitude A. bifurcation_A = np.linspace(1.0, 1.5, 300) steady_states = [] for A_val in bifurcation_A: sol = solve_ivp(pendulum, [0, 200], [0.1, 0.0], t_eval=np.linspace(150, 200, 500), args=(gamma, omega0, A_val, omega_drive)) theta_vals = sol.y[0] % (2 * np.pi) steady_states.append((np.full_like(theta_vals, A_val), theta_vals)) plt.figure(figsize=(10, 6)) for A_vals, thetas in steady_states: plt.plot(A_vals, thetas, ',k', alpha=0.5) plt.title(\"Bifurcation Diagram (A vs \u03b8)\") plt.xlabel(\"Driving Amplitude A\") plt.ylabel(\"\u03b8 mod 2\u03c0\") plt.grid(True) plt.show()","title":"6. Bifurcation Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#7-lyapunov-exponent-estimation","text":"Estimate the largest Lyapunov exponent to determine chaos. def estimate_lyapunov(delta0=1e-8, T_max=100): y1 = np.array([0.1, 0.0]) y2 = y1 + np.array([delta0, 0]) times = np.linspace(0, T_max, 10000) d_list = [] for t in range(len(times) - 1): sol1 = solve_ivp(pendulum, [times[t], times[t+1]], y1, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) sol2 = solve_ivp(pendulum, [times[t], times[t+1]], y2, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) y1 = sol1.y[:, -1] y2 = sol2.y[:, -1] delta = np.linalg.norm(y2 - y1) d_list.append(np.log(delta / delta0)) y2 = y1 + delta0 * (y2 - y1) / delta # Renormalize return times[1:], np.cumsum(d_list) / np.arange(1, len(d_list)+1) ltimes, lyap = estimate_lyapunov() plt.figure(figsize=(8, 4)) plt.plot(ltimes, lyap) plt.title(\"Estimated Largest Lyapunov Exponent\") plt.xlabel(\"Time\") plt.ylabel(\"Lyapunov Exponent\") plt.grid(True) plt.show()","title":"7. Lyapunov Exponent Estimation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#8-exploring-parameters","text":"Experimenting with parameters leads to different behaviors: - Increasing A may cause chaotic motion. - Lowering \u03b3 shows less damping, leading to longer sustained oscillations. - Matching \u03c9 with \u03c9\u2080 creates resonance, producing large amplitudes.","title":"8. Exploring Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extended-visualization-adding-forced-but-undamped-pendulum","text":"This scenario demonstrates periodic motion with sustained energy input and no damping, resulting in regular oscillations without energy loss \u2014 a resonance-friendly setup. We now add the fourth scenario that was previously missing: Case Damping ( \\(b\\) ) Forcing ( \\(A\\) ) Simple Pendulum 0 0 Damped Pendulum 0.5 0 Forced Damped Pendulum 0.5 1.2 Forced (Undamped) Pendulum 0 1.2 \u2705 NEW This configuration shows how the system behaves when it's driven but has no energy loss \u2013 a potentially resonant and unstable regime. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] gamma_forced_undamped = 0.0 A_forced = 1.2 omega_drive = 2.0 sol_forced_undamped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(gamma_forced_undamped, A_forced, omega_drive)) plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol_forced_undamped.t, sol_forced_undamped.y[0]) plt.title(\"Forced (Undamped) Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(1, 2, 2) plt.plot(sol_forced_undamped.y[0], sol_forced_undamped.y[1]) plt.title(\"Forced (Undamped) Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udd04 Extended Visualization: Adding Forced but Undamped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#9-real-world-applications","text":"Energy Harvesters : Pendulums can convert motion into usable energy. Bridge Engineering : Avoiding resonance in suspension bridges is crucial. Washing Machines : Proper damping reduces imbalance. Electronics : RLC circuits have similar equations. Clocks : Pendulum clocks are based on resonance principles.","title":"9. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#10-model-limitations-and-extensions","text":"The model assumes ideal sine driving forces. Real-world damping is often nonlinear. It doesn't account for multi-dimensional motion.","title":"10. Model Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#possible-extensions","text":"Add random or non-periodic forcing. Add nonlinear damping (quadratic drag). Study bifurcation diagrams over varying A or \u03c9. Simulate coupled or double pendulums.","title":"Possible Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#faq-common-questions","text":"1. What makes the forced damped pendulum nonlinear? The presence of the \\(\\sin\\theta\\) term (instead of \\(\\theta\\) ) introduces nonlinearity, which makes the system exhibit complex dynamics such as chaos. 2. Why is damping important in the system? Damping removes energy from the system. Without it, the pendulum would keep oscillating forever if externally driven. 3. What happens at resonance? When the driving frequency matches the natural frequency ( \\(\\omega \\approx \\omega_0\\) ), the system absorbs maximum energy, causing large oscillations. 4. Why do we use the small-angle approximation? It simplifies the math by making the equation linear. It\u2019s only valid for small displacements (typically \\(\\theta < 10^{\\circ}\\) ). 5. What is a Poincar\u00e9 section and why is it useful? It\u2019s a snapshot of the system at regular intervals. It helps identify periodic vs chaotic behavior in a simpler 2D plot. 6. Can this system become chaotic? Yes. With certain combinations of damping, amplitude, and driving frequency, the system becomes highly sensitive to initial conditions and unpredictable. 7. What are real-world analogs of this system? Any system with damping and periodic forcing\u2014like RLC circuits, mechanical oscillators, or climate systems\u2014can be modeled similarly. Feel free to change the parameters and explore how simple rules can create unpredictable patterns. To fully illustrate the transition from simple to complex dynamics, we add simulations for: Simple Pendulum (no damping, no forcing) Damped Pendulum (with damping, no forcing) Forced Damped Pendulum (already shown above) We simulate and visualize angle-time plots and phase diagrams for the first two to complete the progression. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] sol_simple = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.0, 0.0, 0.0)) sol_damped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.5, 0.0, 0.0)) plt.figure(figsize=(14, 10)) plt.subplot(2, 2, 1) plt.plot(sol_simple.t, sol_simple.y[0]) plt.title(\"Simple Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 2) plt.plot(sol_simple.y[0], sol_simple.y[1]) plt.title(\"Simple Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.subplot(2, 2, 3) plt.plot(sol_damped.t, sol_damped.y[0]) plt.title(\"Damped Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 4) plt.plot(sol_damped.y[0], sol_damped.y[1]) plt.title(\"Damped Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show()","title":"FAQ - Common Questions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#appendix-completion-checklist","text":"Category Content Description Included? Theoretical Foundation Differential equation, small-angle approximation, and resonance explanation \u2705 Yes Python Simulation Time-domain simulation using solve_ivp and parameter configuration \u2705 Yes Phase Space Plot Visualization of the angular velocity vs angle (\u03b8 vs \u03c9) \u2705 Yes Poincar\u00e9 Section Stroboscopic mapping to visualize periodic vs chaotic behavior \u2705 Yes Energy Analysis Plot showing kinetic + potential energy over time \u2705 Yes Bifurcation Diagram Diagram showing system behavior vs driving amplitude (A) \u2705 Yes Lyapunov Exponent Numerical estimation of chaos via divergence of nearby trajectories \u2705 Yes Parameter Exploration Discussion of how \u03b3, A, and \u03c9 affect the dynamics \u2705 Yes Real-World Applications Analogies to bridges, electronics, and mechanical systems \u2705 Yes Model Limitations Discussion of assumptions and suggestions for extensions \u2705 Yes FAQ Section Seven clear and relevant conceptual questions with explanations \u2705 Yes","title":"Appendix: Completion Checklist"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation Kepler's Third Law elegantly describes how the time a celestial object takes to complete its orbit depends on the size of the orbit itself. This deep relationship between period and radius provides powerful tools for calculating planetary distances, masses of stars, and understanding orbital mechanics in systems ranging from satellites to exoplanets. Derivation of Kepler's Third Law for Circular Orbits For an object of mass \\(m\\) orbiting a massive body of mass \\(M\\) : The gravitational force provides the necessary centripetal force: \\[ \\frac{GMm}{r^2} = m \\frac{v^2}{r} \\] Simplifying for orbital velocity \\(v\\) : \\[ v = \\sqrt{\\frac{GM}{r}} \\] The orbital period \\(T\\) relates to the circumference of the orbit and velocity: \\[ T = \\frac{2\\pi r}{v} = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{GM} r^3 \\] Thus: \\[ T^2 \\propto r^3 \\] Applications in Astronomy Measuring Masses : Orbital data reveal masses of stars, planets, and galaxies. Mapping Distances : Knowing the period allows inferring distances without direct measurement. Predicting Motion : Useful for satellite placement and mission planning. Real-World Examples 1. Moon's Orbit Around Earth import numpy as np import matplotlib.pyplot as plt # Constants g = 6.67430e-11 # m^3 kg^-1 s^-2 M_earth = 5.972e24 # kg r_moon = 384400e3 # meters # Orbital period calculation T_moon = 2 * np.pi * np.sqrt(r_moon**3 / (g * M_earth)) T_moon_days = T_moon / (60 * 60 * 24) print(f\"Calculated Orbital Period of Moon: {T_moon_days:.2f} days\") Calculated Orbital Period of Moon: 27.45 days Note: This code calculates the Moon's orbital period around Earth using gravitational principles. Visualizing Moon's Orbit # Simulate the orbit n_frames = 250 theta = np.linspace(0, 2*np.pi, n_frames) x_moon = r_moon * np.cos(theta) y_moon = r_moon * np.sin(theta) fig, ax = plt.subplots(figsize=(6,6)) ax.plot(0, 0, 'yo', label='Earth', markersize=12) ax.plot(x_moon, y_moon, 'b--', alpha=0.7) ax.set_aspect('equal') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Moon Orbiting Earth') plt.legend() plt.grid() plt.show() Note: This simulation shows the Moon's near-circular orbit around Earth. 2. Inner Planets in the Solar System # Inner Planets data radii_AU = np.array([0.39, 0.72, 1.00, 1.52]) # AU periods_years = np.array([0.24, 0.62, 1.00, 1.88]) planets = ['Mercury', 'Venus', 'Earth', 'Mars'] r_cubed = radii_AU**3 T_squared = periods_years**2 # Plot plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o-', color='royalblue', label=r'$T^2$ vs $r^3$') for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(5,5), ha='center') plt.xlabel('Orbital Radius$^3$ (AU$^3$)', fontsize=12) plt.ylabel('Orbital Period$^2$ (Years$^2$)', fontsize=12) plt.title(r\"Kepler's Third Law: $T^2 \\propto r^3$\", fontsize=14) plt.legend() plt.grid(True) plt.tight_layout() plt.show() Note: This plot confirms the \\(T^2 \\propto r^3\\) relationship for the inner planets. 3. ISS Orbit Around Earth # Constants for ISS r_iss = 6771e3 # Radius from Earth's center to ISS (Earth's radius + 400 km altitude) # Orbital period calculation for ISS T_iss = 2 * np.pi * np.sqrt(r_iss**3 / (g * M_earth)) T_iss_minutes = T_iss / 60 print(f\"Orbital Period of ISS: {T_iss_minutes:.2f} minutes\") Orbital Period of ISS: 92.42 minutes Note: This example shows that the ISS completes an orbit in about 90 minutes, much faster than the Moon. Log-Log Plot of \\(T^2\\) vs \\(r^3\\) # Log-log plot plt.figure(figsize=(8,6)) plt.loglog(r_cubed, T_squared, 'o-', color='purple') plt.xlabel('log($r^3$) (AU$^3$)') plt.ylabel('log($T^2$) (Years$^2$)') plt.title('Log-Log Plot: Kepler\\'s Third Law') plt.grid(True, which='both', ls='--') plt.tight_layout() plt.show() Note: A straight line in the log-log plot verifies the power-law relationship. Extension to Elliptical Orbits Kepler generalized his Third Law for ellipses by replacing \\(r\\) with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2}{GM} a^3 \\] Thus, whether an orbit is circular or elliptical, the relation remains consistent. Simulation: Fitting \\(T^2\\) vs \\(r^3\\) # Fit and plot linear regression from scipy.stats import linregress slope, intercept, r_value, _, _ = linregress(r_cubed, T_squared) fit_line = slope * r_cubed + intercept plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o', label='Observed') plt.plot(r_cubed, fit_line, '-', label=f\"Fit: $T^2 = {slope:.2f}r^3 + {intercept:.2f}$\") plt.xlabel('$r^3$ (AU$^3$)') plt.ylabel('$T^2$ (Years$^2$)') plt.title(\"Linear Fit of Kepler's Law\") plt.legend() plt.grid() plt.tight_layout() plt.show() Note: The best-fit line shows how closely the data follows Kepler's Third Law. Estimating Masses Using Kepler's Third Law Kepler's Third Law can be rearranged to estimate the mass of a central body when the orbital radius and period of a satellite are known: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Where: - \\(M\\) is the mass of the central body (e.g., the Sun or Earth), - \\(r\\) is the orbital radius (in meters), - \\(T\\) is the orbital period (in seconds), - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2). The following Python code demonstrates how to estimate: the mass of the Sun , using Earth's orbit, and the mass of the Earth , using the Moon's orbit. It also includes a visual bar chart comparing both results, where values are normalized relative to Earth's mass (Earth = 1), making it easier to interpret without large numbers like \\(10^{30}\\) kg. import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # m^3 kg^-1 s^-2 # === Estimating the Sun's Mass using Earth's Orbit === r_earth = 1.496e11 # meters (1 AU) T_earth = 365.25 * 24 * 3600 # seconds (1 year) M_sun = 4 * np.pi**2 * r_earth**3 / (G * T_earth**2) print(f\"Estimated Mass of the Sun: {M_sun:.2e} kg\") # === Estimating the Earth's Mass using Moon's Orbit === r_moon = 384400e3 # meters T_moon = 27.32 * 24 * 3600 # seconds M_earth = 4 * np.pi**2 * r_moon**3 / (G * T_moon**2) print(f\"Estimated Mass of the Earth: {M_earth:.2e} kg\") # === Relative Mass Bar Chart (Logarithmic Scale) === # Normalize masses to Earth = 1 relative_masses = [1, M_sun / M_earth] labels = ['Earth', 'Sun'] plt.figure(figsize=(8,5)) bars = plt.bar(labels, relative_masses, color=['skyblue', 'orange']) plt.yscale('log') # Logarithmic scale to make small values visible plt.ylabel('Mass (in Earth Masses, log scale)') plt.title('Sun vs Earth Mass (Relative Comparison)') # Add value labels on top of bars for bar in bars: yval = bar.get_height() plt.text(bar.get_x() + bar.get_width()/2.0, yval * 1.2, f\"{yval:.0f}\", ha='center') plt.grid(axis='y', linestyle='--', alpha=0.5, which='both') plt.tight_layout() plt.show() Note: Instead of showing masses in kilograms (e.g., \\(1.99 \\times 10^{30}\\) kg for the Sun), we normalize them to Earth = 1. This way: Earth appears as 1 unit , Sun appears as approximately 333,000 Earths . This makes the difference in scale easier to grasp, especially when comparing to everyday objects like a 100 kg person . Conclusion Kepler's Third Law, emerging from simple gravitational principles, enables us to determine the mass of celestial bodies just by observing orbital distances and periods. In this example: Earth's mass was calculated using the Moon's orbit, Sun's mass was calculated using Earth's orbit. Both were visualized on a relative scale , making abstract numbers more intuitive and physically meaningful. Frequently Asked Questions (FAQ) Q1: Why does \\(T^2\\) scale with \\(r^3\\) ? Because gravitational force decreases with distance squared, and orbital speed depends on this force. When combined with the relationship between velocity and period, it leads to \\(T^2 \\propto r^3\\) . Q2: Does Kepler's Third Law apply to non-circular orbits? Yes, it applies to elliptical orbits if we replace \\(r\\) with the semi-major axis \\(a\\) . Q3: Why do satellites like ISS orbit faster than the Moon? The closer an object is to Earth, the stronger the gravitational force, leading to a higher orbital velocity and shorter period. Q4: What happens if another force acts during orbit? Additional forces (like atmospheric drag) can cause deviations from pure Keplerian motion, requiring corrections. Q5: How is Kepler's Law used today? It is critical for satellite deployment, interplanetary travel planning, and discovery of exoplanets by observing transit periods and orbital dynamics. Visit Colab","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law elegantly describes how the time a celestial object takes to complete its orbit depends on the size of the orbit itself. This deep relationship between period and radius provides powerful tools for calculating planetary distances, masses of stars, and understanding orbital mechanics in systems ranging from satellites to exoplanets.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"For an object of mass \\(m\\) orbiting a massive body of mass \\(M\\) : The gravitational force provides the necessary centripetal force: \\[ \\frac{GMm}{r^2} = m \\frac{v^2}{r} \\] Simplifying for orbital velocity \\(v\\) : \\[ v = \\sqrt{\\frac{GM}{r}} \\] The orbital period \\(T\\) relates to the circumference of the orbit and velocity: \\[ T = \\frac{2\\pi r}{v} = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{GM} r^3 \\] Thus: \\[ T^2 \\propto r^3 \\]","title":"Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#applications-in-astronomy","text":"Measuring Masses : Orbital data reveal masses of stars, planets, and galaxies. Mapping Distances : Knowing the period allows inferring distances without direct measurement. Predicting Motion : Useful for satellite placement and mission planning.","title":"Applications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-moons-orbit-around-earth","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 6.67430e-11 # m^3 kg^-1 s^-2 M_earth = 5.972e24 # kg r_moon = 384400e3 # meters # Orbital period calculation T_moon = 2 * np.pi * np.sqrt(r_moon**3 / (g * M_earth)) T_moon_days = T_moon / (60 * 60 * 24) print(f\"Calculated Orbital Period of Moon: {T_moon_days:.2f} days\") Calculated Orbital Period of Moon: 27.45 days Note: This code calculates the Moon's orbital period around Earth using gravitational principles.","title":"1. Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visualizing-moons-orbit","text":"# Simulate the orbit n_frames = 250 theta = np.linspace(0, 2*np.pi, n_frames) x_moon = r_moon * np.cos(theta) y_moon = r_moon * np.sin(theta) fig, ax = plt.subplots(figsize=(6,6)) ax.plot(0, 0, 'yo', label='Earth', markersize=12) ax.plot(x_moon, y_moon, 'b--', alpha=0.7) ax.set_aspect('equal') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Moon Orbiting Earth') plt.legend() plt.grid() plt.show() Note: This simulation shows the Moon's near-circular orbit around Earth.","title":"Visualizing Moon's Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-inner-planets-in-the-solar-system","text":"# Inner Planets data radii_AU = np.array([0.39, 0.72, 1.00, 1.52]) # AU periods_years = np.array([0.24, 0.62, 1.00, 1.88]) planets = ['Mercury', 'Venus', 'Earth', 'Mars'] r_cubed = radii_AU**3 T_squared = periods_years**2 # Plot plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o-', color='royalblue', label=r'$T^2$ vs $r^3$') for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(5,5), ha='center') plt.xlabel('Orbital Radius$^3$ (AU$^3$)', fontsize=12) plt.ylabel('Orbital Period$^2$ (Years$^2$)', fontsize=12) plt.title(r\"Kepler's Third Law: $T^2 \\propto r^3$\", fontsize=14) plt.legend() plt.grid(True) plt.tight_layout() plt.show() Note: This plot confirms the \\(T^2 \\propto r^3\\) relationship for the inner planets.","title":"2. Inner Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-iss-orbit-around-earth","text":"# Constants for ISS r_iss = 6771e3 # Radius from Earth's center to ISS (Earth's radius + 400 km altitude) # Orbital period calculation for ISS T_iss = 2 * np.pi * np.sqrt(r_iss**3 / (g * M_earth)) T_iss_minutes = T_iss / 60 print(f\"Orbital Period of ISS: {T_iss_minutes:.2f} minutes\") Orbital Period of ISS: 92.42 minutes Note: This example shows that the ISS completes an orbit in about 90 minutes, much faster than the Moon.","title":"3. ISS Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#log-log-plot-of-t2-vs-r3","text":"# Log-log plot plt.figure(figsize=(8,6)) plt.loglog(r_cubed, T_squared, 'o-', color='purple') plt.xlabel('log($r^3$) (AU$^3$)') plt.ylabel('log($T^2$) (Years$^2$)') plt.title('Log-Log Plot: Kepler\\'s Third Law') plt.grid(True, which='both', ls='--') plt.tight_layout() plt.show() Note: A straight line in the log-log plot verifies the power-law relationship.","title":"Log-Log Plot of \\(T^2\\) vs \\(r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler generalized his Third Law for ellipses by replacing \\(r\\) with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2}{GM} a^3 \\] Thus, whether an orbit is circular or elliptical, the relation remains consistent.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#simulation-fitting-t2-vs-r3","text":"# Fit and plot linear regression from scipy.stats import linregress slope, intercept, r_value, _, _ = linregress(r_cubed, T_squared) fit_line = slope * r_cubed + intercept plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o', label='Observed') plt.plot(r_cubed, fit_line, '-', label=f\"Fit: $T^2 = {slope:.2f}r^3 + {intercept:.2f}$\") plt.xlabel('$r^3$ (AU$^3$)') plt.ylabel('$T^2$ (Years$^2$)') plt.title(\"Linear Fit of Kepler's Law\") plt.legend() plt.grid() plt.tight_layout() plt.show() Note: The best-fit line shows how closely the data follows Kepler's Third Law.","title":"Simulation: Fitting \\(T^2\\) vs \\(r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#estimating-masses-using-keplers-third-law","text":"Kepler's Third Law can be rearranged to estimate the mass of a central body when the orbital radius and period of a satellite are known: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Where: - \\(M\\) is the mass of the central body (e.g., the Sun or Earth), - \\(r\\) is the orbital radius (in meters), - \\(T\\) is the orbital period (in seconds), - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2). The following Python code demonstrates how to estimate: the mass of the Sun , using Earth's orbit, and the mass of the Earth , using the Moon's orbit. It also includes a visual bar chart comparing both results, where values are normalized relative to Earth's mass (Earth = 1), making it easier to interpret without large numbers like \\(10^{30}\\) kg. import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # m^3 kg^-1 s^-2 # === Estimating the Sun's Mass using Earth's Orbit === r_earth = 1.496e11 # meters (1 AU) T_earth = 365.25 * 24 * 3600 # seconds (1 year) M_sun = 4 * np.pi**2 * r_earth**3 / (G * T_earth**2) print(f\"Estimated Mass of the Sun: {M_sun:.2e} kg\") # === Estimating the Earth's Mass using Moon's Orbit === r_moon = 384400e3 # meters T_moon = 27.32 * 24 * 3600 # seconds M_earth = 4 * np.pi**2 * r_moon**3 / (G * T_moon**2) print(f\"Estimated Mass of the Earth: {M_earth:.2e} kg\") # === Relative Mass Bar Chart (Logarithmic Scale) === # Normalize masses to Earth = 1 relative_masses = [1, M_sun / M_earth] labels = ['Earth', 'Sun'] plt.figure(figsize=(8,5)) bars = plt.bar(labels, relative_masses, color=['skyblue', 'orange']) plt.yscale('log') # Logarithmic scale to make small values visible plt.ylabel('Mass (in Earth Masses, log scale)') plt.title('Sun vs Earth Mass (Relative Comparison)') # Add value labels on top of bars for bar in bars: yval = bar.get_height() plt.text(bar.get_x() + bar.get_width()/2.0, yval * 1.2, f\"{yval:.0f}\", ha='center') plt.grid(axis='y', linestyle='--', alpha=0.5, which='both') plt.tight_layout() plt.show() Note: Instead of showing masses in kilograms (e.g., \\(1.99 \\times 10^{30}\\) kg for the Sun), we normalize them to Earth = 1. This way: Earth appears as 1 unit , Sun appears as approximately 333,000 Earths . This makes the difference in scale easier to grasp, especially when comparing to everyday objects like a 100 kg person .","title":"Estimating Masses Using Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law, emerging from simple gravitational principles, enables us to determine the mass of celestial bodies just by observing orbital distances and periods. In this example: Earth's mass was calculated using the Moon's orbit, Sun's mass was calculated using Earth's orbit. Both were visualized on a relative scale , making abstract numbers more intuitive and physically meaningful.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q1-why-does-t2-scale-with-r3","text":"Because gravitational force decreases with distance squared, and orbital speed depends on this force. When combined with the relationship between velocity and period, it leads to \\(T^2 \\propto r^3\\) .","title":"Q1: Why does \\(T^2\\) scale with \\(r^3\\)?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q2-does-keplers-third-law-apply-to-non-circular-orbits","text":"Yes, it applies to elliptical orbits if we replace \\(r\\) with the semi-major axis \\(a\\) .","title":"Q2: Does Kepler's Third Law apply to non-circular orbits?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q3-why-do-satellites-like-iss-orbit-faster-than-the-moon","text":"The closer an object is to Earth, the stronger the gravitational force, leading to a higher orbital velocity and shorter period.","title":"Q3: Why do satellites like ISS orbit faster than the Moon?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q4-what-happens-if-another-force-acts-during-orbit","text":"Additional forces (like atmospheric drag) can cause deviations from pure Keplerian motion, requiring corrections.","title":"Q4: What happens if another force acts during orbit?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q5-how-is-keplers-law-used-today","text":"It is critical for satellite deployment, interplanetary travel planning, and discovery of exoplanets by observing transit periods and orbital dynamics. Visit Colab","title":"Q5: How is Kepler's Law used today?"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is fundamental to understanding how an object can overcome the gravitational pull of a celestial body. Extending this idea, the definitions of the first , second , and third cosmic velocities describe thresholds for orbiting a planet, escaping a planet's gravity, and leaving a star system entirely. These principles are crucial for designing satellite launches, planning interplanetary missions, and imagining future interstellar travel. Definitions of Cosmic Velocities First Cosmic Velocity ( \\(v_1\\) ): The minimum velocity needed for a stable circular orbit around a planet without propulsion. Second Cosmic Velocity ( \\(v_2\\) ): The escape velocity \u2014 the minimum velocity needed to break free from a celestial body's gravitational field. Third Cosmic Velocity ( \\(v_3\\) ): The minimum velocity needed to escape the gravitational influence of the star (e.g., the Sun) after escaping the planet. Mathematical Derivations 1. First Cosmic Velocity ( \\(v_1\\) ) Derived by equating the gravitational force to the centripetal force needed for circular motion: \\[ \\frac{GMm}{r^2} = m \\frac{v_1^2}{r} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] 2. Second Cosmic Velocity ( \\(v_2\\) ) Derived from energy conservation: kinetic energy must match gravitational potential energy. \\[ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} \\] Thus: \\[ v_2 = \\sqrt{2} v_1 \\] or \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] 3. Third Cosmic Velocity ( \\(v_3\\) ) Requires overcoming the planet's gravity and then escaping the Sun's gravity from Earth's orbit. For approximate calculation: \\[ v_3 \\approx \\sqrt{v_2^2 + v_{esc, Sun}^2} \\] where \\(v_{esc, Sun}\\) is the Sun's escape velocity at the planet's orbital distance. Python Simulation and Visualization We will compute \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) for Earth , Mars , and Jupiter . import numpy as np import matplotlib.pyplot as plt import pandas as pd # Constants G = 6.67430e-11 # Gravitational constant, m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun, kg # Celestial bodies data bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6371e3, 'orbital_radius': 1.496e11}, 'Mars': {'mass': 6.417e23, 'radius': 3389.5e3, 'orbital_radius': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 69911e3, 'orbital_radius': 7.785e11} } # Function to calculate velocities def calculate_cosmic_velocities(mass, radius, orbital_radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 v_esc_sun = np.sqrt(2 * G * M_sun / orbital_radius) v3 = np.sqrt(v2**2 + v_esc_sun**2) return v1, v2, v3 # Store results results = {} for body, data in bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data['mass'], data['radius'], data['orbital_radius']) results[body] = {'mass': data['mass'], 'v1': v1, 'v2': v2, 'v3': v3} # Display results for body, velocities in results.items(): print(f\"{body}: v1 = {velocities['v1']:.2f} m/s, v2 = {velocities['v2']:.2f} m/s, v3 = {velocities['v3']:.2f} m/s\") Earth: v1 = 7909.68 m/s, v2 = 11185.98 m/s, v3 = 43587.65 m/s Mars: v1 = 3554.68 m/s, v2 = 5027.08 m/s, v3 = 34500.32 m/s Jupiter: v1 = 42567.51 m/s, v2 = 60199.54 m/s, v3 = 62968.49 m/s Note: This script calculates the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Graphical Representations 1. Bar Chart of Cosmic Velocities labels = list(results.keys()) v1_vals = [results[body]['v1'] for body in labels] v2_vals = [results[body]['v2'] for body in labels] v3_vals = [results[body]['v3'] for body in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (m/s)') ax.set_title('Comparison of Cosmic Velocities') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() 2. Line Plot of Cosmic Velocities plt.figure(figsize=(10,6)) plt.plot(labels, v1_vals, 'o-', label='First Cosmic Velocity') plt.plot(labels, v2_vals, 's-', label='Second Cosmic Velocity') plt.plot(labels, v3_vals, 'd-', label='Third Cosmic Velocity') plt.xlabel('Celestial Body') plt.ylabel('Velocity (m/s)') plt.title('Trends of Cosmic Velocities') plt.legend() plt.grid(True) plt.tight_layout() plt.show() 3. Tabular Summary of Velocities df = pd.DataFrame(results).T[['v1', 'v2', 'v3']] print(df) 4. Log-Log Plot (Mass vs Escape Velocity) mass_vals = [results[body]['mass'] for body in labels] v2_vals = [results[body]['v2'] for body in labels] plt.figure(figsize=(8,6)) plt.loglog(mass_vals, v2_vals, 'o-', markersize=8) plt.xlabel('Mass (kg)') plt.ylabel('Second Cosmic Velocity (m/s)') plt.title('Log-Log Plot: Mass vs Escape Velocity') plt.grid(True, which='both', ls='--') plt.tight_layout() plt.show() 5. Pie Chart (Relative Escape Velocities) plt.figure(figsize=(8,8)) plt.pie(v2_vals, labels=labels, autopct='%1.1f%%', startangle=140) plt.title('Relative Escape Velocities of Planets') plt.tight_layout() plt.show() Importance in Space Exploration First Cosmic Velocity: Required to place satellites into stable orbit. Second Cosmic Velocity: Needed for missions leaving a planet, such as Moon and Mars exploration. Third Cosmic Velocity: Necessary for deep-space missions and interstellar exploration planning. Understanding these velocities informs spacecraft design, mission trajectories, and fuel requirements. Conclusion Escape velocities and cosmic velocities set the fundamental energy thresholds that govern space exploration. Mastery of these concepts has enabled humanity to place satellites in orbit, reach other planets, and imagine future journeys beyond the Solar System. Frequently Asked Questions (FAQ) Q1: Why is the second cosmic velocity higher than the first? Because escaping a planet's gravity requires more energy than simply maintaining a stable orbit. Q2: Why does Jupiter have a much higher escape velocity than Earth? Due to its significantly greater mass and size, creating a stronger gravitational field. Q3: What challenges exist in achieving the third cosmic velocity? The enormous amount of energy and precise navigation needed to escape a star's gravity well. Q4: How are these velocities achieved in practice? Using multi-stage rockets, gravitational assists, and carefully planned launch trajectories. Q5: Are cosmic velocities affected by atmospheres? Yes, atmospheric drag must be overcome, requiring additional velocity beyond the theoretical minimums when launching from planets with atmospheres like Earth. Visit Colab","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is fundamental to understanding how an object can overcome the gravitational pull of a celestial body. Extending this idea, the definitions of the first , second , and third cosmic velocities describe thresholds for orbiting a planet, escaping a planet's gravity, and leaving a star system entirely. These principles are crucial for designing satellite launches, planning interplanetary missions, and imagining future interstellar travel.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"First Cosmic Velocity ( \\(v_1\\) ): The minimum velocity needed for a stable circular orbit around a planet without propulsion. Second Cosmic Velocity ( \\(v_2\\) ): The escape velocity \u2014 the minimum velocity needed to break free from a celestial body's gravitational field. Third Cosmic Velocity ( \\(v_3\\) ): The minimum velocity needed to escape the gravitational influence of the star (e.g., the Sun) after escaping the planet.","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v_1","text":"Derived by equating the gravitational force to the centripetal force needed for circular motion: \\[ \\frac{GMm}{r^2} = m \\frac{v_1^2}{r} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\]","title":"1. First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-v_2","text":"Derived from energy conservation: kinetic energy must match gravitational potential energy. \\[ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} \\] Thus: \\[ v_2 = \\sqrt{2} v_1 \\] or \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\]","title":"2. Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v_3","text":"Requires overcoming the planet's gravity and then escaping the Sun's gravity from Earth's orbit. For approximate calculation: \\[ v_3 \\approx \\sqrt{v_2^2 + v_{esc, Sun}^2} \\] where \\(v_{esc, Sun}\\) is the Sun's escape velocity at the planet's orbital distance.","title":"3. Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation-and-visualization","text":"We will compute \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) for Earth , Mars , and Jupiter . import numpy as np import matplotlib.pyplot as plt import pandas as pd # Constants G = 6.67430e-11 # Gravitational constant, m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun, kg # Celestial bodies data bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6371e3, 'orbital_radius': 1.496e11}, 'Mars': {'mass': 6.417e23, 'radius': 3389.5e3, 'orbital_radius': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 69911e3, 'orbital_radius': 7.785e11} } # Function to calculate velocities def calculate_cosmic_velocities(mass, radius, orbital_radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 v_esc_sun = np.sqrt(2 * G * M_sun / orbital_radius) v3 = np.sqrt(v2**2 + v_esc_sun**2) return v1, v2, v3 # Store results results = {} for body, data in bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data['mass'], data['radius'], data['orbital_radius']) results[body] = {'mass': data['mass'], 'v1': v1, 'v2': v2, 'v3': v3} # Display results for body, velocities in results.items(): print(f\"{body}: v1 = {velocities['v1']:.2f} m/s, v2 = {velocities['v2']:.2f} m/s, v3 = {velocities['v3']:.2f} m/s\") Earth: v1 = 7909.68 m/s, v2 = 11185.98 m/s, v3 = 43587.65 m/s Mars: v1 = 3554.68 m/s, v2 = 5027.08 m/s, v3 = 34500.32 m/s Jupiter: v1 = 42567.51 m/s, v2 = 60199.54 m/s, v3 = 62968.49 m/s Note: This script calculates the first, second, and third cosmic velocities for Earth, Mars, and Jupiter.","title":"Python Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#graphical-representations","text":"","title":"Graphical Representations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-bar-chart-of-cosmic-velocities","text":"labels = list(results.keys()) v1_vals = [results[body]['v1'] for body in labels] v2_vals = [results[body]['v2'] for body in labels] v3_vals = [results[body]['v3'] for body in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (m/s)') ax.set_title('Comparison of Cosmic Velocities') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show()","title":"1. Bar Chart of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-line-plot-of-cosmic-velocities","text":"plt.figure(figsize=(10,6)) plt.plot(labels, v1_vals, 'o-', label='First Cosmic Velocity') plt.plot(labels, v2_vals, 's-', label='Second Cosmic Velocity') plt.plot(labels, v3_vals, 'd-', label='Third Cosmic Velocity') plt.xlabel('Celestial Body') plt.ylabel('Velocity (m/s)') plt.title('Trends of Cosmic Velocities') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"2. Line Plot of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-tabular-summary-of-velocities","text":"df = pd.DataFrame(results).T[['v1', 'v2', 'v3']] print(df)","title":"3. Tabular Summary of Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-log-log-plot-mass-vs-escape-velocity","text":"mass_vals = [results[body]['mass'] for body in labels] v2_vals = [results[body]['v2'] for body in labels] plt.figure(figsize=(8,6)) plt.loglog(mass_vals, v2_vals, 'o-', markersize=8) plt.xlabel('Mass (kg)') plt.ylabel('Second Cosmic Velocity (m/s)') plt.title('Log-Log Plot: Mass vs Escape Velocity') plt.grid(True, which='both', ls='--') plt.tight_layout() plt.show()","title":"4. Log-Log Plot (Mass vs Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-pie-chart-relative-escape-velocities","text":"plt.figure(figsize=(8,8)) plt.pie(v2_vals, labels=labels, autopct='%1.1f%%', startangle=140) plt.title('Relative Escape Velocities of Planets') plt.tight_layout() plt.show()","title":"5. Pie Chart (Relative Escape Velocities)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity: Required to place satellites into stable orbit. Second Cosmic Velocity: Needed for missions leaving a planet, such as Moon and Mars exploration. Third Cosmic Velocity: Necessary for deep-space missions and interstellar exploration planning. Understanding these velocities informs spacecraft design, mission trajectories, and fuel requirements.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Escape velocities and cosmic velocities set the fundamental energy thresholds that govern space exploration. Mastery of these concepts has enabled humanity to place satellites in orbit, reach other planets, and imagine future journeys beyond the Solar System.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q1-why-is-the-second-cosmic-velocity-higher-than-the-first","text":"Because escaping a planet's gravity requires more energy than simply maintaining a stable orbit.","title":"Q1: Why is the second cosmic velocity higher than the first?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q2-why-does-jupiter-have-a-much-higher-escape-velocity-than-earth","text":"Due to its significantly greater mass and size, creating a stronger gravitational field.","title":"Q2: Why does Jupiter have a much higher escape velocity than Earth?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q3-what-challenges-exist-in-achieving-the-third-cosmic-velocity","text":"The enormous amount of energy and precise navigation needed to escape a star's gravity well.","title":"Q3: What challenges exist in achieving the third cosmic velocity?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q4-how-are-these-velocities-achieved-in-practice","text":"Using multi-stage rockets, gravitational assists, and carefully planned launch trajectories.","title":"Q4: How are these velocities achieved in practice?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q5-are-cosmic-velocities-affected-by-atmospheres","text":"Yes, atmospheric drag must be overcome, requiring additional velocity beyond the theoretical minimums when launching from planets with atmospheres like Earth. Visit Colab","title":"Q5: Are cosmic velocities affected by atmospheres?"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions such as velocity, angle, and altitude. This problem blends principles of orbital mechanics, energy conservation, and numerical simulation. Understanding these trajectories is critical for missions like satellite deployment, reentry modules, or escaping Earth's gravity. Types of Possible Trajectories Depending on the initial velocity ( \\(v_0\\) ) and altitude ( \\(h\\) ), a payload can follow different paths: Elliptical Orbit : \\(v_0\\) < escape velocity; payload remains bound to Earth. Parabolic Trajectory : \\(v_0\\) \u2248 escape velocity; payload barely escapes Earth's gravity. Hyperbolic Trajectory : \\(v_0\\) > escape velocity; payload escapes with excess kinetic energy. Suborbital Trajectory : \\(v_0\\) too low for orbit; payload falls back to Earth. Fundamental Equations Gravitational Force: \\(F = \\frac{GMm}{r^2}\\) Gravitational Potential Energy: \\(U = -\\frac{GMm}{r}\\) Kinetic Energy: \\(K = \\frac{1}{2}mv^2\\) Total Energy (E): \\(E = K + U\\) If \\(E < 0\\) : Elliptical orbit If \\(E = 0\\) : Parabolic trajectory If \\(E > 0\\) : Hyperbolic escape Constants and Initial Setup import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6371e3 # Radius of Earth (m) altitude = 300e3 # Payload release altitude (m) r0 = R_earth + altitude v_escape = np.sqrt(2 * G * M_earth / r0) print(f\"Escape velocity at {altitude/1000:.0f} km altitude: {v_escape/1000:.2f} km/s\") Escape velocity at 300 km altitude: 10.93 km/s Note: The escape velocity at the release altitude is printed for reference. Trajectories of Payloads Extended Simulation: Payload Trajectories with Multiple Initial Velocities To better understand how different initial velocities influence a payload's trajectory, we simulate a wide range of speeds from 5.0 km/s to 13.0 km/s , in 0.5 km/s steps . This extended analysis helps illustrate the transition from suborbital to hyperbolic escape paths more clearly. Simulation Setup We reuse the principles of Newtonian gravity and apply Euler integration for simplicity. The gravitational field is modeled as originating from a point-mass Earth, and the payload is released from a 300 km altitude above Earth's surface. The escape velocity from this altitude is approximately: \\[ v_{\\text{escape}} = \\sqrt{\\frac{2GM}{r}} \\approx 10.93 \\ \\text{km/s} \\] Below, we simulate and plot trajectories for initial velocities ranging from 5.0 km/s to 13.0 km/s . import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_earth = 5.972e24 # kg R_earth = 6371e3 # m altitude = 300e3 # m r0 = R_earth + altitude dt = 1 # time step (s) steps = 12000 # Velocity range from 5.0 km/s to 13.0 km/s v_kms = np.arange(5.0, 13.5, 0.5) # km/s colors = plt.cm.viridis(np.linspace(0, 1, len(v_kms))) fig, ax = plt.subplots(figsize=(9, 9)) for i, (v_km, color) in enumerate(zip(v_kms, colors)): v0 = v_km * 1000 # convert to m/s pos = np.array([r0, 0]) vel = np.array([0, v0]) x_vals, y_vals = [], [] for _ in range(steps): r = np.linalg.norm(pos) if r < R_earth: break acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt x_vals.append(pos[0]) y_vals.append(pos[1]) ax.plot(x_vals, y_vals, label=f\"{v_km:.1f} km/s\", color=color) # Draw Earth theta = np.linspace(0, 2*np.pi, 300) ax.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='cornflowerblue', alpha=0.6, label=\"Earth\") ax.plot(0, 0, 'yo', label=\"Center of Earth\") ax.set_aspect('equal') ax.set_xlim(-3e7, 3e7) ax.set_ylim(-3e7, 3e7) ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_title(\"Trajectories in a Gravitational Field with Multiple Initial Velocities\") ax.legend(loc='upper right', fontsize=8, ncol=2) ax.grid(True) plt.tight_layout() plt.show() Visual Output Each colored curve in the graph represents the path of a payload launched with a different initial velocity. The Earth is shown as a filled blue circle. Trajectories change dramatically based on speed: Low speeds (5\u20137 km/s) : payload falls back \u2014 suborbital. Around 7.8 km/s : stable elliptical orbit. At ~11.2 km/s : payload barely escapes \u2014 parabolic. Above 11.5 km/s : payload escapes Earth's gravity \u2014 hyperbolic. Summary Table: Initial Velocity vs Trajectory Type Initial Velocity (km/s) Behavior Trajectory Type 5.0 \u2013 7.0 Falls back to Earth Suborbital ~7.8 Stable orbit Elliptical ~11.2 Just escapes Earth's gravity Parabolic 11.5 \u2013 13.0 Escapes with extra energy Hyperbolic Conclusion This simulation highlights the sensitive dependence of trajectory on initial velocity . Even a small increase in speed can shift the outcome from a crash to an escape trajectory. These insights are crucial in: - Planning satellite launches, - Designing escape/reentry paths, - Interplanetary mission navigation. By visualizing these effects, we better understand real-world spacecraft behavior in Earth\u2019s gravitational field. initial_velocities = [0.7 * v_escape, v_escape, 1.2 * v_escape] labels = ['Elliptical Orbit', 'Parabolic Escape', 'Hyperbolic Escape'] dt = 1 # Time step (s) steps = 15000 fig, ax_traj = plt.subplots(figsize=(8,8)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) x_vals, y_vals = [], [] for _ in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt x_vals.append(pos[0]) y_vals.append(pos[1]) if r < R_earth: break ax_traj.plot(x_vals, y_vals, label=label) # Draw Earth theta = np.linspace(0, 2*np.pi, 100) ax_traj.plot(R_earth*np.cos(theta), R_earth*np.sin(theta), 'k') ax_traj.set_aspect('equal') ax_traj.set_xlim(-2e7, 2e7) ax_traj.set_ylim(-2e7, 2e7) ax_traj.set_xlabel('x (m)') ax_traj.set_ylabel('y (m)') ax_traj.set_title('Payload Trajectories') ax_traj.legend() ax_traj.grid() plt.show() Note: This plot shows how different initial speeds result in different types of trajectories. Energy vs Time fig, ax_energy = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) E_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt energy = 0.5 * np.linalg.norm(vel)**2 - G * M_earth / r E_vals.append(energy) t_vals.append(t * dt) if r < R_earth: break ax_energy.plot(t_vals, E_vals, label=label) ax_energy.set_xlabel('Time (s)') ax_energy.set_ylabel('Specific Energy (J/kg)') ax_energy.set_title('Energy vs Time') ax_energy.legend() ax_energy.grid() plt.show() Note: This plot shows how the total specific energy evolves over time for different cases. Velocity vs Time fig, ax_velocity = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) v_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt v_vals.append(np.linalg.norm(vel)) t_vals.append(t * dt) if r < R_earth: break ax_velocity.plot(t_vals, v_vals, label=label) ax_velocity.set_xlabel('Time (s)') ax_velocity.set_ylabel('Velocity (m/s)') ax_velocity.set_title('Velocity vs Time') ax_velocity.legend() ax_velocity.grid() plt.show() Note: This plot shows how the payload speed changes with time depending on initial conditions. Distance from Earth vs Time fig, ax_distance = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) r_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt r_vals.append(r) t_vals.append(t * dt) if r < R_earth: break ax_distance.plot(t_vals, r_vals, label=label) ax_distance.set_xlabel('Time (s)') ax_distance.set_ylabel('Distance from Earth Center (m)') ax_distance.set_title('Distance vs Time') ax_distance.legend() ax_distance.grid() plt.show() Note: This plot shows the distance of the payload from the Earth's center as a function of time. Conclusion Simulating and understanding trajectories for varying initial speeds and angles is essential for modern space missions. From orbital insertions to deep-space escapes, mastering these mechanics is a fundamental part of aerospace engineering. Frequently Asked Questions (FAQ) Q1: Why simulate different angles? Different angles allow payloads to achieve stable orbit, escape, or crash depending on mission needs. Q2: How does energy help classify trajectory type? Total energy being negative, zero, or positive immediately tells whether the motion is elliptical, parabolic, or hyperbolic. Q3: Can air resistance be included? Yes, adding atmospheric drag would make the simulation more realistic but more complex. Q4: Why does velocity decrease after release? Gravitational pull reduces upward velocity; depending on initial speed, the payload may orbit, escape, or fall. Q5: How accurate is Euler's method here? For small enough time steps ( \\(\\Delta t\\) ), it gives reasonably accurate approximations, but better methods exist (e.g., Runge-Kutta 4th order). Visit Colab","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions such as velocity, angle, and altitude. This problem blends principles of orbital mechanics, energy conservation, and numerical simulation. Understanding these trajectories is critical for missions like satellite deployment, reentry modules, or escaping Earth's gravity.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-possible-trajectories","text":"Depending on the initial velocity ( \\(v_0\\) ) and altitude ( \\(h\\) ), a payload can follow different paths: Elliptical Orbit : \\(v_0\\) < escape velocity; payload remains bound to Earth. Parabolic Trajectory : \\(v_0\\) \u2248 escape velocity; payload barely escapes Earth's gravity. Hyperbolic Trajectory : \\(v_0\\) > escape velocity; payload escapes with excess kinetic energy. Suborbital Trajectory : \\(v_0\\) too low for orbit; payload falls back to Earth.","title":"Types of Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#fundamental-equations","text":"Gravitational Force: \\(F = \\frac{GMm}{r^2}\\) Gravitational Potential Energy: \\(U = -\\frac{GMm}{r}\\) Kinetic Energy: \\(K = \\frac{1}{2}mv^2\\) Total Energy (E): \\(E = K + U\\) If \\(E < 0\\) : Elliptical orbit If \\(E = 0\\) : Parabolic trajectory If \\(E > 0\\) : Hyperbolic escape","title":"Fundamental Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants-and-initial-setup","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6371e3 # Radius of Earth (m) altitude = 300e3 # Payload release altitude (m) r0 = R_earth + altitude v_escape = np.sqrt(2 * G * M_earth / r0) print(f\"Escape velocity at {altitude/1000:.0f} km altitude: {v_escape/1000:.2f} km/s\") Escape velocity at 300 km altitude: 10.93 km/s Note: The escape velocity at the release altitude is printed for reference.","title":"Constants and Initial Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-payloads","text":"","title":"Trajectories of Payloads"},{"location":"1%20Physics/2%20Gravity/Problem_3/#extended-simulation-payload-trajectories-with-multiple-initial-velocities","text":"To better understand how different initial velocities influence a payload's trajectory, we simulate a wide range of speeds from 5.0 km/s to 13.0 km/s , in 0.5 km/s steps . This extended analysis helps illustrate the transition from suborbital to hyperbolic escape paths more clearly.","title":"Extended Simulation: Payload Trajectories with Multiple Initial Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-setup","text":"We reuse the principles of Newtonian gravity and apply Euler integration for simplicity. The gravitational field is modeled as originating from a point-mass Earth, and the payload is released from a 300 km altitude above Earth's surface. The escape velocity from this altitude is approximately: \\[ v_{\\text{escape}} = \\sqrt{\\frac{2GM}{r}} \\approx 10.93 \\ \\text{km/s} \\] Below, we simulate and plot trajectories for initial velocities ranging from 5.0 km/s to 13.0 km/s . import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_earth = 5.972e24 # kg R_earth = 6371e3 # m altitude = 300e3 # m r0 = R_earth + altitude dt = 1 # time step (s) steps = 12000 # Velocity range from 5.0 km/s to 13.0 km/s v_kms = np.arange(5.0, 13.5, 0.5) # km/s colors = plt.cm.viridis(np.linspace(0, 1, len(v_kms))) fig, ax = plt.subplots(figsize=(9, 9)) for i, (v_km, color) in enumerate(zip(v_kms, colors)): v0 = v_km * 1000 # convert to m/s pos = np.array([r0, 0]) vel = np.array([0, v0]) x_vals, y_vals = [], [] for _ in range(steps): r = np.linalg.norm(pos) if r < R_earth: break acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt x_vals.append(pos[0]) y_vals.append(pos[1]) ax.plot(x_vals, y_vals, label=f\"{v_km:.1f} km/s\", color=color) # Draw Earth theta = np.linspace(0, 2*np.pi, 300) ax.fill(R_earth*np.cos(theta), R_earth*np.sin(theta), color='cornflowerblue', alpha=0.6, label=\"Earth\") ax.plot(0, 0, 'yo', label=\"Center of Earth\") ax.set_aspect('equal') ax.set_xlim(-3e7, 3e7) ax.set_ylim(-3e7, 3e7) ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_title(\"Trajectories in a Gravitational Field with Multiple Initial Velocities\") ax.legend(loc='upper right', fontsize=8, ncol=2) ax.grid(True) plt.tight_layout() plt.show()","title":"Simulation Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visual-output","text":"Each colored curve in the graph represents the path of a payload launched with a different initial velocity. The Earth is shown as a filled blue circle. Trajectories change dramatically based on speed: Low speeds (5\u20137 km/s) : payload falls back \u2014 suborbital. Around 7.8 km/s : stable elliptical orbit. At ~11.2 km/s : payload barely escapes \u2014 parabolic. Above 11.5 km/s : payload escapes Earth's gravity \u2014 hyperbolic.","title":"Visual Output"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary-table-initial-velocity-vs-trajectory-type","text":"Initial Velocity (km/s) Behavior Trajectory Type 5.0 \u2013 7.0 Falls back to Earth Suborbital ~7.8 Stable orbit Elliptical ~11.2 Just escapes Earth's gravity Parabolic 11.5 \u2013 13.0 Escapes with extra energy Hyperbolic","title":"Summary Table: Initial Velocity vs Trajectory Type"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"This simulation highlights the sensitive dependence of trajectory on initial velocity . Even a small increase in speed can shift the outcome from a crash to an escape trajectory. These insights are crucial in: - Planning satellite launches, - Designing escape/reentry paths, - Interplanetary mission navigation. By visualizing these effects, we better understand real-world spacecraft behavior in Earth\u2019s gravitational field. initial_velocities = [0.7 * v_escape, v_escape, 1.2 * v_escape] labels = ['Elliptical Orbit', 'Parabolic Escape', 'Hyperbolic Escape'] dt = 1 # Time step (s) steps = 15000 fig, ax_traj = plt.subplots(figsize=(8,8)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) x_vals, y_vals = [], [] for _ in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt x_vals.append(pos[0]) y_vals.append(pos[1]) if r < R_earth: break ax_traj.plot(x_vals, y_vals, label=label) # Draw Earth theta = np.linspace(0, 2*np.pi, 100) ax_traj.plot(R_earth*np.cos(theta), R_earth*np.sin(theta), 'k') ax_traj.set_aspect('equal') ax_traj.set_xlim(-2e7, 2e7) ax_traj.set_ylim(-2e7, 2e7) ax_traj.set_xlabel('x (m)') ax_traj.set_ylabel('y (m)') ax_traj.set_title('Payload Trajectories') ax_traj.legend() ax_traj.grid() plt.show() Note: This plot shows how different initial speeds result in different types of trajectories.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#energy-vs-time","text":"fig, ax_energy = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) E_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt energy = 0.5 * np.linalg.norm(vel)**2 - G * M_earth / r E_vals.append(energy) t_vals.append(t * dt) if r < R_earth: break ax_energy.plot(t_vals, E_vals, label=label) ax_energy.set_xlabel('Time (s)') ax_energy.set_ylabel('Specific Energy (J/kg)') ax_energy.set_title('Energy vs Time') ax_energy.legend() ax_energy.grid() plt.show() Note: This plot shows how the total specific energy evolves over time for different cases.","title":"Energy vs Time"},{"location":"1%20Physics/2%20Gravity/Problem_3/#velocity-vs-time","text":"fig, ax_velocity = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) v_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt v_vals.append(np.linalg.norm(vel)) t_vals.append(t * dt) if r < R_earth: break ax_velocity.plot(t_vals, v_vals, label=label) ax_velocity.set_xlabel('Time (s)') ax_velocity.set_ylabel('Velocity (m/s)') ax_velocity.set_title('Velocity vs Time') ax_velocity.legend() ax_velocity.grid() plt.show() Note: This plot shows how the payload speed changes with time depending on initial conditions.","title":"Velocity vs Time"},{"location":"1%20Physics/2%20Gravity/Problem_3/#distance-from-earth-vs-time","text":"fig, ax_distance = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) r_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt r_vals.append(r) t_vals.append(t * dt) if r < R_earth: break ax_distance.plot(t_vals, r_vals, label=label) ax_distance.set_xlabel('Time (s)') ax_distance.set_ylabel('Distance from Earth Center (m)') ax_distance.set_title('Distance vs Time') ax_distance.legend() ax_distance.grid() plt.show() Note: This plot shows the distance of the payload from the Earth's center as a function of time.","title":"Distance from Earth vs Time"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion_1","text":"Simulating and understanding trajectories for varying initial speeds and angles is essential for modern space missions. From orbital insertions to deep-space escapes, mastering these mechanics is a fundamental part of aerospace engineering.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q1-why-simulate-different-angles","text":"Different angles allow payloads to achieve stable orbit, escape, or crash depending on mission needs.","title":"Q1: Why simulate different angles?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q2-how-does-energy-help-classify-trajectory-type","text":"Total energy being negative, zero, or positive immediately tells whether the motion is elliptical, parabolic, or hyperbolic.","title":"Q2: How does energy help classify trajectory type?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q3-can-air-resistance-be-included","text":"Yes, adding atmospheric drag would make the simulation more realistic but more complex.","title":"Q3: Can air resistance be included?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q4-why-does-velocity-decrease-after-release","text":"Gravitational pull reduces upward velocity; depending on initial speed, the payload may orbit, escape, or fall.","title":"Q4: Why does velocity decrease after release?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q5-how-accurate-is-eulers-method-here","text":"For small enough time steps ( \\(\\Delta t\\) ), it gives reasonably accurate approximations, but better methods exist (e.g., Runge-Kutta 4th order). Visit Colab","title":"Q5: How accurate is Euler's method here?"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Pattern from a Hexagonal Array of Wave Sources Motivation Visualizing wave interference helps us understand fundamental concepts of physics like: Superposition : Waves add or cancel depending on their relative phase Coherence : Stable phase relationships are key to recognizable patterns Symmetry in Physics : The layout of sources creates geometrically rich structures When wave sources are arranged in a regular hexagon , the interference pattern becomes beautifully complex. These types of patterns are not just visually pleasing \u2014 they also appear in real-life systems like: Speaker arrays Laser beam interference Quantum interference experiments Water ripple tanks in educational settings Assumptions and Parameters All sources emit circular, coherent waves simultaneously Identical parameters for all sources: Amplitude \\( A = 1.0 \\) Wavelength \\( \\lambda = 1.0 \\) Frequency \\( f = 1.0 \\) The layout is a perfect regular hexagon The simulation is observed at different time steps \\( t \\in \\{0, 0.25, 0.5, 0.75, 1.0\\} \\) The superposition principle is used: [ Z(x, y, t) = \\sum_{i=1}^{N} A \\sin(k r_i - \\omega t + \\phi) ] Simulation and Plotting (2D + 3D) import numpy as np import matplotlib.pyplot as plt # Wave Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 # Grid Setup x = np.linspace(-5, 5, 600) y = np.linspace(-5, 5, 600) X, Y = np.meshgrid(x, y) # Generate hexagon sources def generate_hexagon_sources(radius=2.0): N = 6 angles = np.linspace(0, 2 * np.pi, N, endpoint=False) return [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Plot 2D pattern at different times def plot_2d_interference(t, cmap='plasma'): sources = generate_hexagon_sources() Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) plt.figure(figsize=(6, 6)) plt.contourf(X, Y, Z, levels=150, cmap=cmap) for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f'2D Interference Pattern (t = {t:.2f})') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.colorbar(label='Wave Displacement') plt.grid(True) plt.show() # Display multiple snapshots for t_snapshot in [0, 0.25, 0.5, 0.75, 1.0]: plot_2d_interference(t_snapshot) # Plot 3D Surface def plot_3d_interference(t): sources = generate_hexagon_sources() Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(f'3D Interference Surface (t = {t:.2f})') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Amplitude') plt.tight_layout() plt.show() # Show 3D plot at t=0 plot_3d_interference(t=0) Observations \ud83d\udfe2 Constructive Interference Wave crests from different sources align, amplifying the total displacement (bright/elevated zones) \ud83d\udd34 Destructive Interference Crests and troughs cancel each other, resulting in near-zero displacement (dark/flat regions) \ud83d\udd37 Hexagonal Symmetry Clear 6-fold symmetry in wavefronts due to regular hexagon layout \ud83d\udd04 Temporal Dynamics As time evolves, the interference pattern shifts in space \u2014 simulating a breathing effect Conclusion This simulation reveals the beauty and complexity of wave interference created by coherent sources arranged in a hexagonal configuration . Key Takeaways: \ud83d\udcd0 Geometry defines interference \u2014 the number and arrangement of sources directly shape the pattern \ud83d\udcca Wavelength controls fringe spacing \u2014 shorter wavelengths yield denser patterns \ud83e\udde0 Simple wave rules \u2192 complex results \u2014 a powerful concept in many physical systems Explore Further: Use triangular , square , or octagonal source layouts Introduce phase differences to simulate more realistic scenarios Animate wave motion with matplotlib.animation Apply this logic to optics , acoustics , or quantum mechanics \u2753 Frequently Asked Questions (FAQ) \u2753 Why a hexagon? Hexagons provide rich symmetry and are seen in many physical systems like crystals and molecular patterns. Their layout creates circularly symmetric interference fringes. \u2753 What if I change the polygon? Using a triangle gives simpler results; squares lead to grid-like symmetry. The pattern complexity grows with the number of sides. \u2753 Can this be animated? Yes! You can create smooth animations by looping over t and redrawing each frame with matplotlib.animation.FuncAnimation . \u2753 Are the waves realistic? This model assumes idealized point sources in an infinite medium with perfect coherence. It demonstrates concepts , not specific real-world behavior. \u2753 How can I simulate noise or non-coherence? Introduce random phase offsets or amplitude differences per source. \u2753 Can I use this for sound or light? Yes \u2014 the math of wave interference applies to any kind of wave : sound, light, water, or even probability amplitudes in quantum systems. Visit Colab","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-pattern-from-a-hexagonal-array-of-wave-sources","text":"","title":"Interference Pattern from a Hexagonal Array of Wave Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Visualizing wave interference helps us understand fundamental concepts of physics like: Superposition : Waves add or cancel depending on their relative phase Coherence : Stable phase relationships are key to recognizable patterns Symmetry in Physics : The layout of sources creates geometrically rich structures When wave sources are arranged in a regular hexagon , the interference pattern becomes beautifully complex. These types of patterns are not just visually pleasing \u2014 they also appear in real-life systems like: Speaker arrays Laser beam interference Quantum interference experiments Water ripple tanks in educational settings","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#assumptions-and-parameters","text":"All sources emit circular, coherent waves simultaneously Identical parameters for all sources: Amplitude \\( A = 1.0 \\) Wavelength \\( \\lambda = 1.0 \\) Frequency \\( f = 1.0 \\) The layout is a perfect regular hexagon The simulation is observed at different time steps \\( t \\in \\{0, 0.25, 0.5, 0.75, 1.0\\} \\) The superposition principle is used: [ Z(x, y, t) = \\sum_{i=1}^{N} A \\sin(k r_i - \\omega t + \\phi) ]","title":"Assumptions and Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-and-plotting-2d-3d","text":"import numpy as np import matplotlib.pyplot as plt # Wave Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 # Grid Setup x = np.linspace(-5, 5, 600) y = np.linspace(-5, 5, 600) X, Y = np.meshgrid(x, y) # Generate hexagon sources def generate_hexagon_sources(radius=2.0): N = 6 angles = np.linspace(0, 2 * np.pi, N, endpoint=False) return [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Plot 2D pattern at different times def plot_2d_interference(t, cmap='plasma'): sources = generate_hexagon_sources() Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) plt.figure(figsize=(6, 6)) plt.contourf(X, Y, Z, levels=150, cmap=cmap) for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f'2D Interference Pattern (t = {t:.2f})') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.colorbar(label='Wave Displacement') plt.grid(True) plt.show() # Display multiple snapshots for t_snapshot in [0, 0.25, 0.5, 0.75, 1.0]: plot_2d_interference(t_snapshot) # Plot 3D Surface def plot_3d_interference(t): sources = generate_hexagon_sources() Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(f'3D Interference Surface (t = {t:.2f})') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Amplitude') plt.tight_layout() plt.show() # Show 3D plot at t=0 plot_3d_interference(t=0)","title":"Simulation and Plotting (2D + 3D)"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations","text":"\ud83d\udfe2 Constructive Interference Wave crests from different sources align, amplifying the total displacement (bright/elevated zones) \ud83d\udd34 Destructive Interference Crests and troughs cancel each other, resulting in near-zero displacement (dark/flat regions) \ud83d\udd37 Hexagonal Symmetry Clear 6-fold symmetry in wavefronts due to regular hexagon layout \ud83d\udd04 Temporal Dynamics As time evolves, the interference pattern shifts in space \u2014 simulating a breathing effect","title":"Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation reveals the beauty and complexity of wave interference created by coherent sources arranged in a hexagonal configuration .","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/#key-takeaways","text":"\ud83d\udcd0 Geometry defines interference \u2014 the number and arrangement of sources directly shape the pattern \ud83d\udcca Wavelength controls fringe spacing \u2014 shorter wavelengths yield denser patterns \ud83e\udde0 Simple wave rules \u2192 complex results \u2014 a powerful concept in many physical systems","title":"Key Takeaways:"},{"location":"1%20Physics/3%20Waves/Problem_1/#explore-further","text":"Use triangular , square , or octagonal source layouts Introduce phase differences to simulate more realistic scenarios Animate wave motion with matplotlib.animation Apply this logic to optics , acoustics , or quantum mechanics","title":"Explore Further:"},{"location":"1%20Physics/3%20Waves/Problem_1/#frequently-asked-questions-faq","text":"","title":"\u2753 Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/3%20Waves/Problem_1/#why-a-hexagon","text":"Hexagons provide rich symmetry and are seen in many physical systems like crystals and molecular patterns. Their layout creates circularly symmetric interference fringes.","title":"\u2753 Why a hexagon?"},{"location":"1%20Physics/3%20Waves/Problem_1/#what-if-i-change-the-polygon","text":"Using a triangle gives simpler results; squares lead to grid-like symmetry. The pattern complexity grows with the number of sides.","title":"\u2753 What if I change the polygon?"},{"location":"1%20Physics/3%20Waves/Problem_1/#can-this-be-animated","text":"Yes! You can create smooth animations by looping over t and redrawing each frame with matplotlib.animation.FuncAnimation .","title":"\u2753 Can this be animated?"},{"location":"1%20Physics/3%20Waves/Problem_1/#are-the-waves-realistic","text":"This model assumes idealized point sources in an infinite medium with perfect coherence. It demonstrates concepts , not specific real-world behavior.","title":"\u2753 Are the waves realistic?"},{"location":"1%20Physics/3%20Waves/Problem_1/#how-can-i-simulate-noise-or-non-coherence","text":"Introduce random phase offsets or amplitude differences per source.","title":"\u2753 How can I simulate noise or non-coherence?"},{"location":"1%20Physics/3%20Waves/Problem_1/#can-i-use-this-for-sound-or-light","text":"Yes \u2014 the math of wave interference applies to any kind of wave : sound, light, water, or even probability amplitudes in quantum systems. Visit Colab","title":"\u2753 Can I use this for sound or light?"},{"location":"1%20Physics/3%20Waves/problem_1fix/","text":"Problem 1 Interference Pattern from a Hexagonal Array of Wave Sources Motivation Visualizing wave interference helps us understand fundamental concepts of physics like: Superposition : Waves add or cancel depending on their relative phase Coherence : Stable phase relationships are key to recognizable patterns Symmetry in Physics : The layout of sources creates geometrically rich structures When wave sources are arranged in a regular hexagon , the interference pattern becomes beautifully complex. These types of patterns are not just visually pleasing \u2014 they also appear in real-life systems like: Speaker arrays Laser beam interference Quantum interference experiments Water ripple tanks in educational settings Assumptions and Parameters All sources emit circular, coherent waves simultaneously Identical parameters for all sources: Amplitude \\(A = 1.0\\) Wavelength \\(\\lambda = 1.0\\) Frequency \\(f = 1.0\\) The layout is a perfect regular hexagon The simulation includes comparisons with 1 and 2 sources for clarity Observed at time steps \\(t \\in \\{0, 0.25, 0.5, 0.75, 1.0\\}\\) The superposition principle is used: $$ Z(x, y, t) = \\sum_{i=1}^{N} A \\sin(k r_i - \\omega t + \\phi) $$ Simulation and Plotting (1 Source, 2 Sources, 6 Sources) import numpy as np import matplotlib.pyplot as plt from matplotlib import animation from IPython.display import Image # Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 x = np.linspace(-5, 5, 600) y = np.linspace(-5, 5, 600) X, Y = np.meshgrid(x, y) # Source definitions def generate_single_source(): return [(0, 0)] def generate_two_sources(sep=4.0): return [(-sep/2, 0), (sep/2, 0)] def generate_hexagon_sources(radius=2.0): angles = np.linspace(0, 2 * np.pi, 6, endpoint=False) return [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # 2D Interference Plot def plot_2d_interference(t, sources, title_suffix=\"\"): Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) plt.figure(figsize=(6, 6)) plt.contourf(X, Y, Z, levels=150, cmap='plasma') for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f\"2D Interference Pattern {title_suffix} (t = {t:.2f})\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.colorbar(label='Wave Displacement') plt.grid(True) plt.show() # Snapshots for each source layout for t_snapshot in [0, 0.25, 0.5, 0.75, 1.0]: plot_2d_interference(t_snapshot, generate_single_source(), \"(1 Source)\") plot_2d_interference(t_snapshot, generate_two_sources(), \"(2 Sources)\") plot_2d_interference(t_snapshot, generate_hexagon_sources(), \"(6 Sources)\") 3D Interference Surface (Hexagonal Case) def plot_3d_interference(t, sources): from mpl_toolkits.mplot3d import Axes3D Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(f'3D Interference Surface (t = {t:.2f})') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Amplitude') plt.tight_layout() plt.show() plot_3d_interference(0, generate_hexagon_sources()) Animated GIF (Hexagon) def create_animation_gif(sources, filename=\"interference.gif\", duration=2.0): fig, ax = plt.subplots(figsize=(6, 6)) # \u0130lk Z'yi hesapla ve vmin/vmax belirle t0 = 0 Z0 = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z0 += A * np.sin(k * r - omega * t0 + phi) img = ax.imshow(Z0, cmap='plasma', origin='lower', extent=[-5, 5, -5, 5], vmin=-len(sources), vmax=len(sources)) ax.set_title(\"Interference Animation\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") def update(frame): t = frame / 20 Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) img.set_data(Z) return [img] ani = animation.FuncAnimation(fig, update, frames=40, interval=duration*1000/40, blit=True) ani.save(filename, writer='pillow') plt.close() create_animation_gif(generate_hexagon_sources()) ShowImage(filename=\"interference.gif\") Observations \ud83d\udfe2 Constructive Interference Wave crests align, creating bright/elevated zones \ud83d\udd34 Destructive Interference Crests and troughs cancel, producing dark/flat regions \ud83d\udd37 Hexagonal Symmetry The six-source layout reveals rich, six-fold symmetry \ud83d\udd04 Temporal Dynamics The pattern evolves with time, creating a breathing effect Conclusion This simulation reveals the beauty and complexity of wave interference from coherent sources arranged in geometric patterns. By exploring 1, 2, and 6 source cases, we observe how interference builds from simple to complex. Key Takeaways: \ud83d\udcd0 Geometry defines interference \ud83d\udcca Wavelength controls fringe spacing \ud83e\udde0 Simple wave rules produce complex patterns Explore Further: Add triangular, square, or circular layouts Introduce phase offsets or noise Apply to optics, acoustics, or quantum wave interference \u2753 Frequently Asked Questions (FAQ) \u2753 Why include 1 and 2 sources? To understand wave interference gradually, starting from the simplest case. \u2753 Why a hexagon? Hexagons offer natural symmetry and occur in crystals, molecular structures, and wave physics. \u2753 Can this be animated? Yes, via matplotlib.animation and pillow for exporting .gif . \u2753 Are the waves realistic? They represent idealized, perfectly coherent sources for conceptual clarity. \u2753 How do I add non-coherence? Add random phase differences or amplitude noise to each source. Open in Colab \u2197","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/problem_1fix/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/problem_1fix/#interference-pattern-from-a-hexagonal-array-of-wave-sources","text":"","title":"Interference Pattern from a Hexagonal Array of Wave Sources"},{"location":"1%20Physics/3%20Waves/problem_1fix/#motivation","text":"Visualizing wave interference helps us understand fundamental concepts of physics like: Superposition : Waves add or cancel depending on their relative phase Coherence : Stable phase relationships are key to recognizable patterns Symmetry in Physics : The layout of sources creates geometrically rich structures When wave sources are arranged in a regular hexagon , the interference pattern becomes beautifully complex. These types of patterns are not just visually pleasing \u2014 they also appear in real-life systems like: Speaker arrays Laser beam interference Quantum interference experiments Water ripple tanks in educational settings","title":"Motivation"},{"location":"1%20Physics/3%20Waves/problem_1fix/#assumptions-and-parameters","text":"All sources emit circular, coherent waves simultaneously Identical parameters for all sources: Amplitude \\(A = 1.0\\) Wavelength \\(\\lambda = 1.0\\) Frequency \\(f = 1.0\\) The layout is a perfect regular hexagon The simulation includes comparisons with 1 and 2 sources for clarity Observed at time steps \\(t \\in \\{0, 0.25, 0.5, 0.75, 1.0\\}\\) The superposition principle is used: $$ Z(x, y, t) = \\sum_{i=1}^{N} A \\sin(k r_i - \\omega t + \\phi) $$","title":"Assumptions and Parameters"},{"location":"1%20Physics/3%20Waves/problem_1fix/#simulation-and-plotting-1-source-2-sources-6-sources","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib import animation from IPython.display import Image # Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 x = np.linspace(-5, 5, 600) y = np.linspace(-5, 5, 600) X, Y = np.meshgrid(x, y) # Source definitions def generate_single_source(): return [(0, 0)] def generate_two_sources(sep=4.0): return [(-sep/2, 0), (sep/2, 0)] def generate_hexagon_sources(radius=2.0): angles = np.linspace(0, 2 * np.pi, 6, endpoint=False) return [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # 2D Interference Plot def plot_2d_interference(t, sources, title_suffix=\"\"): Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) plt.figure(figsize=(6, 6)) plt.contourf(X, Y, Z, levels=150, cmap='plasma') for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f\"2D Interference Pattern {title_suffix} (t = {t:.2f})\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.colorbar(label='Wave Displacement') plt.grid(True) plt.show() # Snapshots for each source layout for t_snapshot in [0, 0.25, 0.5, 0.75, 1.0]: plot_2d_interference(t_snapshot, generate_single_source(), \"(1 Source)\") plot_2d_interference(t_snapshot, generate_two_sources(), \"(2 Sources)\") plot_2d_interference(t_snapshot, generate_hexagon_sources(), \"(6 Sources)\")","title":"Simulation and Plotting (1 Source, 2 Sources, 6 Sources)"},{"location":"1%20Physics/3%20Waves/problem_1fix/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/problem_1fix/#3d-interference-surface-hexagonal-case","text":"def plot_3d_interference(t, sources): from mpl_toolkits.mplot3d import Axes3D Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(f'3D Interference Surface (t = {t:.2f})') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Amplitude') plt.tight_layout() plt.show() plot_3d_interference(0, generate_hexagon_sources())","title":"3D Interference Surface (Hexagonal Case)"},{"location":"1%20Physics/3%20Waves/problem_1fix/#_2","text":"","title":""},{"location":"1%20Physics/3%20Waves/problem_1fix/#animated-gif-hexagon","text":"def create_animation_gif(sources, filename=\"interference.gif\", duration=2.0): fig, ax = plt.subplots(figsize=(6, 6)) # \u0130lk Z'yi hesapla ve vmin/vmax belirle t0 = 0 Z0 = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z0 += A * np.sin(k * r - omega * t0 + phi) img = ax.imshow(Z0, cmap='plasma', origin='lower', extent=[-5, 5, -5, 5], vmin=-len(sources), vmax=len(sources)) ax.set_title(\"Interference Animation\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") def update(frame): t = frame / 20 Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) img.set_data(Z) return [img] ani = animation.FuncAnimation(fig, update, frames=40, interval=duration*1000/40, blit=True) ani.save(filename, writer='pillow') plt.close() create_animation_gif(generate_hexagon_sources()) ShowImage(filename=\"interference.gif\")","title":"Animated GIF (Hexagon)"},{"location":"1%20Physics/3%20Waves/problem_1fix/#observations","text":"\ud83d\udfe2 Constructive Interference Wave crests align, creating bright/elevated zones \ud83d\udd34 Destructive Interference Crests and troughs cancel, producing dark/flat regions \ud83d\udd37 Hexagonal Symmetry The six-source layout reveals rich, six-fold symmetry \ud83d\udd04 Temporal Dynamics The pattern evolves with time, creating a breathing effect","title":"Observations"},{"location":"1%20Physics/3%20Waves/problem_1fix/#conclusion","text":"This simulation reveals the beauty and complexity of wave interference from coherent sources arranged in geometric patterns. By exploring 1, 2, and 6 source cases, we observe how interference builds from simple to complex.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/problem_1fix/#key-takeaways","text":"\ud83d\udcd0 Geometry defines interference \ud83d\udcca Wavelength controls fringe spacing \ud83e\udde0 Simple wave rules produce complex patterns","title":"Key Takeaways:"},{"location":"1%20Physics/3%20Waves/problem_1fix/#explore-further","text":"Add triangular, square, or circular layouts Introduce phase offsets or noise Apply to optics, acoustics, or quantum wave interference","title":"Explore Further:"},{"location":"1%20Physics/3%20Waves/problem_1fix/#frequently-asked-questions-faq","text":"","title":"\u2753 Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/3%20Waves/problem_1fix/#why-include-1-and-2-sources","text":"To understand wave interference gradually, starting from the simplest case.","title":"\u2753 Why include 1 and 2 sources?"},{"location":"1%20Physics/3%20Waves/problem_1fix/#why-a-hexagon","text":"Hexagons offer natural symmetry and occur in crystals, molecular structures, and wave physics.","title":"\u2753 Why a hexagon?"},{"location":"1%20Physics/3%20Waves/problem_1fix/#can-this-be-animated","text":"Yes, via matplotlib.animation and pillow for exporting .gif .","title":"\u2753 Can this be animated?"},{"location":"1%20Physics/3%20Waves/problem_1fix/#are-the-waves-realistic","text":"They represent idealized, perfectly coherent sources for conceptual clarity.","title":"\u2753 Are the waves realistic?"},{"location":"1%20Physics/3%20Waves/problem_1fix/#how-do-i-add-non-coherence","text":"Add random phase differences or amplitude noise to each source. Open in Colab \u2197","title":"\u2753 How do I add non-coherence?"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 (Advanced): Simulating the Effects of the Lorentz Force \ud83e\udde0 Motivation The Lorentz force governs how charged particles move through electric and magnetic fields. This law explains: Why particles spiral in magnetic traps How beams are curved in cyclotrons Why plasma drifts in crossed fields This simulation will help visualize these effects in multiple physical contexts. \u2699\ufe0f Lorentz Force Formula \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] \\( \\vec{F} \\) : Total electromagnetic force \\( q \\) : Particle charge \\( \\vec{v} \\) : Velocity of the particle \\( \\vec{E} \\) : Electric field \\( \\vec{B} \\) : Magnetic field We\u2019ll simulate the motion using Euler's method. \ud83d\udd2c Simulation Setup (Python Code) import numpy as np import matplotlib.pyplot as plt # Parameters q = 1.0 m = 1.0 dt = 0.01 steps = 2000 def simulate_lorentz(E, B, v0): r = np.zeros((steps, 3), dtype=float) v = v0.copy().astype(float) r[0] = np.array([0.0, 0.0, 0.0]) for i in range(1, steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r[i] = r[i-1] + v * dt return r # Example: only magnetic field E = np.array([0.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) v0 = np.array([1.0, 0.0, 0.0]) trajectory = simulate_lorentz(E, B, v0) plt.figure(figsize=(6, 6)) plt.plot(trajectory[:, 0], trajectory[:, 1]) plt.title(\"Charged Particle in Uniform Magnetic Field (2D)\") plt.xlabel(\"x position\") plt.ylabel(\"y position\") plt.axis(\"equal\") plt.grid(True) plt.show() \ud83e\uddf2 Scenario 1: Only Magnetic Field (Uniform B, No E) Magnetic field: \\( \\vec{B} = [0, 0, 1] \\) No electric field Initial velocity \\( \\vec{v}_0 = [1, 0, 0] \\) E = np.array([0, 0, 0]) B = np.array([0, 0, 1]) v0 = np.array([1, 0, 0]) r1 = simulate_lorentz(E, B, v0) plt.figure(figsize=(6, 6)) plt.plot(r1[:, 0], r1[:, 1]) plt.title(\"Scenario 1: Uniform Magnetic Field (2D)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis(\"equal\") plt.grid(True) plt.tight_layout() plt.show() \ud83d\udd0d Explanation: The particle undergoes circular motion in the x\u2013y plane. The Larmor radius is constant, determined by velocity and field strength: [ r_L = \\frac{mv}{|qB|} = 1 \\text{ (in our units)} ] \u26a1 Scenario 2: Only Electric Field (No B) Electric field: \\( \\vec{E} = [1, 0, 0] \\) No magnetic field \\( \\vec{v}_0 = [0, 0, 0] \\) E = np.array([1, 0, 0]) B = np.array([0, 0, 0]) v0 = np.array([0, 0, 0]) r2 = simulate_lorentz(E, B, v0) plt.figure(figsize=(6, 6)) plt.plot(r2[:, 0], r2[:, 1]) plt.title(\"Scenario 2: Uniform Electric Field (2D)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.tight_layout() plt.show() \ud83d\udd0d Explanation: The particle accelerates linearly in the direction of the electric field (x-direction). This is classical Newtonian motion under a constant force: [ a = \\frac{qE}{m} ] \ud83d\udd01 Scenario 3: Crossed Electric and Magnetic Fields \\( \\vec{E} = [1, 0, 0] \\) \\( \\vec{B} = [0, 0, 1] \\) \\( \\vec{v}_0 = [0, 0, 0] \\) E = np.array([1, 0, 0]) B = np.array([0, 0, 1]) v0 = np.array([0, 0, 0]) r3 = simulate_lorentz(E, B, v0) plt.figure(figsize=(6, 6)) plt.plot(r3[:, 0], r3[:, 1]) plt.title(\"Scenario 3: Crossed E and B Fields (2D)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis(\"equal\") plt.grid(True) plt.tight_layout() plt.show() \ud83d\udd0d Explanation: The particle experiences a drift motion. Resulting velocity: [ \\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} ] This creates a spiral drift or \u201c \\( \\vec{E} \\times \\vec{B} \\) \u201d drift. \ud83c\udf00 Scenario 4: 3D Helical Motion Electric field: \\( \\vec{E} = [0, 0, 0] \\) Magnetic field: \\( \\vec{B} = [0, 0, 1] \\) Initial velocity: \\( \\vec{v}_0 = [1, 0, 1] \\) from mpl_toolkits.mplot3d import Axes3D E = np.array([0, 0, 0]) B = np.array([0, 0, 1]) v0 = np.array([1, 0, 1]) r4 = simulate_lorentz(E, B, v0) fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot3D(r4[:, 0], r4[:, 1], r4[:, 2]) ax.set_title(\"Scenario 4: Helical Motion in 3D (B Field Only)\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show() \ud83d\udd0d Explanation: The particle spirals along the z-direction due to its initial vertical velocity. The pitch of the helix depends on \\( v_z \\) . \ud83d\udcca Parameter Exploration Summary Scenario Fields Initial Velocity Resulting Motion 1 \\( \\vec{B} \\neq 0 \\) only \\( [1, 0, 0] \\) Circular (2D) 2 \\( \\vec{E} \\neq 0 \\) only \\( [0, 0, 0] \\) Linear acceleration 3 Crossed \\( \\vec{E}, \\vec{B} \\) \\( [0, 0, 0] \\) Drift motion 4 \\( \\vec{B} \\neq 0 \\) , 3D \\( [1, 0, 1] \\) Helical motion (3D) \u2753 Frequently Asked Questions (FAQ) \ud83d\udca1 Why is the motion circular in a magnetic field? Because the force is always perpendicular to the velocity \u2192 centripetal motion. \ud83d\udca1 What happens if fields are non-uniform? Motion becomes highly complex \u2014 chaotic or trapped depending on gradients. \ud83d\udca1 Is this used in real applications? Yes, in devices like: - Mass spectrometers - Cyclotrons - Tokamaks (fusion) \ud83d\udca1 What\u2019s next for deeper simulations? Use Runge-Kutta for more accuracy Include field gradients or collisions \u2705 Final Remarks This simulation demonstrates how the Lorentz force governs particle dynamics in multiple fields. Through graphical representation and parameter exploration, we can see how fundamental electromagnetic principles manifest in real-world physics. Visit Colab","title":"Problem 1 (Advanced): Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1-advanced-simulating-the-effects-of-the-lorentz-force","text":"","title":"Problem 1 (Advanced): Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force governs how charged particles move through electric and magnetic fields. This law explains: Why particles spiral in magnetic traps How beams are curved in cyclotrons Why plasma drifts in crossed fields This simulation will help visualize these effects in multiple physical contexts.","title":"\ud83e\udde0 Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-formula","text":"\\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] \\( \\vec{F} \\) : Total electromagnetic force \\( q \\) : Particle charge \\( \\vec{v} \\) : Velocity of the particle \\( \\vec{E} \\) : Electric field \\( \\vec{B} \\) : Magnetic field We\u2019ll simulate the motion using Euler's method.","title":"\u2699\ufe0f Lorentz Force Formula"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-setup-python-code","text":"import numpy as np import matplotlib.pyplot as plt # Parameters q = 1.0 m = 1.0 dt = 0.01 steps = 2000 def simulate_lorentz(E, B, v0): r = np.zeros((steps, 3), dtype=float) v = v0.copy().astype(float) r[0] = np.array([0.0, 0.0, 0.0]) for i in range(1, steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r[i] = r[i-1] + v * dt return r # Example: only magnetic field E = np.array([0.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) v0 = np.array([1.0, 0.0, 0.0]) trajectory = simulate_lorentz(E, B, v0) plt.figure(figsize=(6, 6)) plt.plot(trajectory[:, 0], trajectory[:, 1]) plt.title(\"Charged Particle in Uniform Magnetic Field (2D)\") plt.xlabel(\"x position\") plt.ylabel(\"y position\") plt.axis(\"equal\") plt.grid(True) plt.show()","title":"\ud83d\udd2c Simulation Setup (Python Code)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-1-only-magnetic-field-uniform-b-no-e","text":"Magnetic field: \\( \\vec{B} = [0, 0, 1] \\) No electric field Initial velocity \\( \\vec{v}_0 = [1, 0, 0] \\) E = np.array([0, 0, 0]) B = np.array([0, 0, 1]) v0 = np.array([1, 0, 0]) r1 = simulate_lorentz(E, B, v0) plt.figure(figsize=(6, 6)) plt.plot(r1[:, 0], r1[:, 1]) plt.title(\"Scenario 1: Uniform Magnetic Field (2D)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis(\"equal\") plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83e\uddf2 Scenario 1: Only Magnetic Field (Uniform B, No E)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation","text":"The particle undergoes circular motion in the x\u2013y plane. The Larmor radius is constant, determined by velocity and field strength: [ r_L = \\frac{mv}{|qB|} = 1 \\text{ (in our units)} ]","title":"\ud83d\udd0d Explanation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-2-only-electric-field-no-b","text":"Electric field: \\( \\vec{E} = [1, 0, 0] \\) No magnetic field \\( \\vec{v}_0 = [0, 0, 0] \\) E = np.array([1, 0, 0]) B = np.array([0, 0, 0]) v0 = np.array([0, 0, 0]) r2 = simulate_lorentz(E, B, v0) plt.figure(figsize=(6, 6)) plt.plot(r2[:, 0], r2[:, 1]) plt.title(\"Scenario 2: Uniform Electric Field (2D)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.tight_layout() plt.show()","title":"\u26a1 Scenario 2: Only Electric Field (No B)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation_1","text":"The particle accelerates linearly in the direction of the electric field (x-direction). This is classical Newtonian motion under a constant force: [ a = \\frac{qE}{m} ]","title":"\ud83d\udd0d Explanation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-3-crossed-electric-and-magnetic-fields","text":"\\( \\vec{E} = [1, 0, 0] \\) \\( \\vec{B} = [0, 0, 1] \\) \\( \\vec{v}_0 = [0, 0, 0] \\) E = np.array([1, 0, 0]) B = np.array([0, 0, 1]) v0 = np.array([0, 0, 0]) r3 = simulate_lorentz(E, B, v0) plt.figure(figsize=(6, 6)) plt.plot(r3[:, 0], r3[:, 1]) plt.title(\"Scenario 3: Crossed E and B Fields (2D)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis(\"equal\") plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udd01 Scenario 3: Crossed Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation_2","text":"The particle experiences a drift motion. Resulting velocity: [ \\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} ] This creates a spiral drift or \u201c \\( \\vec{E} \\times \\vec{B} \\) \u201d drift.","title":"\ud83d\udd0d Explanation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-4-3d-helical-motion","text":"Electric field: \\( \\vec{E} = [0, 0, 0] \\) Magnetic field: \\( \\vec{B} = [0, 0, 1] \\) Initial velocity: \\( \\vec{v}_0 = [1, 0, 1] \\) from mpl_toolkits.mplot3d import Axes3D E = np.array([0, 0, 0]) B = np.array([0, 0, 1]) v0 = np.array([1, 0, 1]) r4 = simulate_lorentz(E, B, v0) fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot3D(r4[:, 0], r4[:, 1], r4[:, 2]) ax.set_title(\"Scenario 4: Helical Motion in 3D (B Field Only)\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show()","title":"\ud83c\udf00 Scenario 4: 3D Helical Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation_3","text":"The particle spirals along the z-direction due to its initial vertical velocity. The pitch of the helix depends on \\( v_z \\) .","title":"\ud83d\udd0d Explanation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-exploration-summary","text":"Scenario Fields Initial Velocity Resulting Motion 1 \\( \\vec{B} \\neq 0 \\) only \\( [1, 0, 0] \\) Circular (2D) 2 \\( \\vec{E} \\neq 0 \\) only \\( [0, 0, 0] \\) Linear acceleration 3 Crossed \\( \\vec{E}, \\vec{B} \\) \\( [0, 0, 0] \\) Drift motion 4 \\( \\vec{B} \\neq 0 \\) , 3D \\( [1, 0, 1] \\) Helical motion (3D)","title":"\ud83d\udcca Parameter Exploration Summary"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#frequently-asked-questions-faq","text":"","title":"\u2753 Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#why-is-the-motion-circular-in-a-magnetic-field","text":"Because the force is always perpendicular to the velocity \u2192 centripetal motion.","title":"\ud83d\udca1 Why is the motion circular in a magnetic field?"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-happens-if-fields-are-non-uniform","text":"Motion becomes highly complex \u2014 chaotic or trapped depending on gradients.","title":"\ud83d\udca1 What happens if fields are non-uniform?"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#is-this-used-in-real-applications","text":"Yes, in devices like: - Mass spectrometers - Cyclotrons - Tokamaks (fusion)","title":"\ud83d\udca1 Is this used in real applications?"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#whats-next-for-deeper-simulations","text":"Use Runge-Kutta for more accuracy Include field gradients or collisions","title":"\ud83d\udca1 What\u2019s next for deeper simulations?"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#final-remarks","text":"This simulation demonstrates how the Lorentz force governs particle dynamics in multiple fields. Through graphical representation and parameter exploration, we can see how fundamental electromagnetic principles manifest in real-world physics. Visit Colab","title":"\u2705 Final Remarks"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 (Advanced): Equivalent Resistance Using Graph Theory \ud83e\udde0 Motivation Simplifying complex resistor networks by hand is inefficient and error-prone. With graph theory , we can: Model any circuit as a graph Apply automated series and parallel simplifications Visualize each step to improve understanding \ud83d\udd0c Case Study: 4-Node Complex Circuit We begin with a circuit composed of 4 nodes and 6 resistors: A\u2013B: 10\u03a9 B\u2013C: 5\u03a9 C\u2013D: 15\u03a9 A\u2013D: 30\u03a9 B\u2013D: 20\u03a9 A\u2013C: 25\u03a9 import networkx as nx import matplotlib.pyplot as plt def draw_circuit(G, title): pos = nx.spring_layout(G, seed=42) labels = nx.get_edge_attributes(G, 'resistance') plt.figure(figsize=(7, 5)) nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=700) nx.draw_networkx_edge_labels(G, pos, edge_labels={k: f\"{v}\u03a9\" for k, v in labels.items()}) plt.title(title) plt.axis('off') plt.tight_layout() plt.show() # Define initial graph G = nx.Graph() G.add_edge('A', 'B', resistance=10) G.add_edge('B', 'C', resistance=5) G.add_edge('C', 'D', resistance=15) G.add_edge('A', 'D', resistance=30) G.add_edge('B', 'D', resistance=20) G.add_edge('A', 'C', resistance=25) draw_circuit(G, \"Step 0: Initial Complex Circuit\") \ud83d\udd04 Step 1: Combine C\u2013D and B\u2013D as Parallel Resistors C\u2013D = 15\u03a9 B\u2013D = 20\u03a9 We model them both as connecting to B\u2013C in parallel (simplified path from C to B via D). \\[ \\frac{1}{R_{eq}} = \\frac{1}{15} + \\frac{1}{20} \\Rightarrow R_{eq} \u2248 8.57\u03a9 \\] G.remove_edge('C', 'D') G.remove_edge('B', 'D') G.add_edge('C', 'B', resistance=1 / (1/15 + 1/20)) # \u2248 8.57\u03a9 draw_circuit(G, \"Step 1: Replaced C\u2013D and B\u2013D with C\u2013B (\u22488.57\u03a9)\") \ud83e\uddf1 Step 2: Combine B\u2013C and B\u2013A as Series C\u2013B = 8.57\u03a9 B\u2013A = 10\u03a9 \u2192 Combine: [ R_{eq} = 8.57 + 10 = 18.57\u03a9 ] G.remove_edge('B', 'C') G.remove_edge('A', 'B') G.add_edge('A', 'C', resistance=18.57) draw_circuit(G, \"Step 2: A\u2013C Updated via B in Series (18.57\u03a9)\") \u267b\ufe0f Step 3: Final Parallel Combination Now we have: A\u2013C (18.57\u03a9) from above A\u2013C (25\u03a9) already in the graph \\[ \\frac{1}{R_{eq}} = \\frac{1}{18.57} + \\frac{1}{25} \\Rightarrow R_{eq} \u2248 10.66\u03a9 \\] G.remove_edges_from(list(G.edges('A'))) G.add_edge('A', 'C', resistance=1 / (1/18.57 + 1/25)) draw_circuit(G, \"Step 3: Final A\u2013C Resistance \u2248 10.66\u03a9\") \u2705 Final Result \\[ \\boxed{R_{eq} \\approx 10.66\\, \\Omega} \\] \ud83d\udcca Observations and Analysis The initial circuit had multiple redundant paths between nodes. We applied: Parallel reduction (C\u2013D and B\u2013D) Series simplification (via B) Final parallel merge (A\u2013C) Every step was verified by graphical visualization. \u2753 Frequently Asked Questions (FAQ) \ud83d\udca1 What if the graph contains cycles like bridges? You\u2019ll need \u0394\u2013Y (Delta\u2013Wye) transformations to handle those cases, not covered here. \ud83d\udca1 Can this scale to 10+ node graphs? Yes, but you should implement auto-detection of series/parallel edges and recursion. \ud83d\udca1 Does the order of reductions matter? In most linear cases, no. But for non-trivial topologies, correct detection is essential. \ud83d\udca1 How do I extend this to symbolic (unknown) resistors? Use sympy and symbolic matrices instead of numerical weights. Visit Colab","title":"Problem 1 (Advanced): Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1-advanced-equivalent-resistance-using-graph-theory","text":"","title":"Problem 1 (Advanced): Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Simplifying complex resistor networks by hand is inefficient and error-prone. With graph theory , we can: Model any circuit as a graph Apply automated series and parallel simplifications Visualize each step to improve understanding","title":"\ud83e\udde0 Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#case-study-4-node-complex-circuit","text":"We begin with a circuit composed of 4 nodes and 6 resistors: A\u2013B: 10\u03a9 B\u2013C: 5\u03a9 C\u2013D: 15\u03a9 A\u2013D: 30\u03a9 B\u2013D: 20\u03a9 A\u2013C: 25\u03a9 import networkx as nx import matplotlib.pyplot as plt def draw_circuit(G, title): pos = nx.spring_layout(G, seed=42) labels = nx.get_edge_attributes(G, 'resistance') plt.figure(figsize=(7, 5)) nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=700) nx.draw_networkx_edge_labels(G, pos, edge_labels={k: f\"{v}\u03a9\" for k, v in labels.items()}) plt.title(title) plt.axis('off') plt.tight_layout() plt.show() # Define initial graph G = nx.Graph() G.add_edge('A', 'B', resistance=10) G.add_edge('B', 'C', resistance=5) G.add_edge('C', 'D', resistance=15) G.add_edge('A', 'D', resistance=30) G.add_edge('B', 'D', resistance=20) G.add_edge('A', 'C', resistance=25) draw_circuit(G, \"Step 0: Initial Complex Circuit\")","title":"\ud83d\udd0c Case Study: 4-Node Complex Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-1-combine-cd-and-bd-as-parallel-resistors","text":"C\u2013D = 15\u03a9 B\u2013D = 20\u03a9 We model them both as connecting to B\u2013C in parallel (simplified path from C to B via D). \\[ \\frac{1}{R_{eq}} = \\frac{1}{15} + \\frac{1}{20} \\Rightarrow R_{eq} \u2248 8.57\u03a9 \\] G.remove_edge('C', 'D') G.remove_edge('B', 'D') G.add_edge('C', 'B', resistance=1 / (1/15 + 1/20)) # \u2248 8.57\u03a9 draw_circuit(G, \"Step 1: Replaced C\u2013D and B\u2013D with C\u2013B (\u22488.57\u03a9)\")","title":"\ud83d\udd04 Step 1: Combine C\u2013D and B\u2013D as Parallel Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-2-combine-bc-and-ba-as-series","text":"C\u2013B = 8.57\u03a9 B\u2013A = 10\u03a9 \u2192 Combine: [ R_{eq} = 8.57 + 10 = 18.57\u03a9 ] G.remove_edge('B', 'C') G.remove_edge('A', 'B') G.add_edge('A', 'C', resistance=18.57) draw_circuit(G, \"Step 2: A\u2013C Updated via B in Series (18.57\u03a9)\")","title":"\ud83e\uddf1 Step 2: Combine B\u2013C and B\u2013A as Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-3-final-parallel-combination","text":"Now we have: A\u2013C (18.57\u03a9) from above A\u2013C (25\u03a9) already in the graph \\[ \\frac{1}{R_{eq}} = \\frac{1}{18.57} + \\frac{1}{25} \\Rightarrow R_{eq} \u2248 10.66\u03a9 \\] G.remove_edges_from(list(G.edges('A'))) G.add_edge('A', 'C', resistance=1 / (1/18.57 + 1/25)) draw_circuit(G, \"Step 3: Final A\u2013C Resistance \u2248 10.66\u03a9\")","title":"\u267b\ufe0f Step 3: Final Parallel Combination"},{"location":"1%20Physics/5%20Circuits/Problem_1/#final-result","text":"\\[ \\boxed{R_{eq} \\approx 10.66\\, \\Omega} \\]","title":"\u2705 Final Result"},{"location":"1%20Physics/5%20Circuits/Problem_1/#observations-and-analysis","text":"The initial circuit had multiple redundant paths between nodes. We applied: Parallel reduction (C\u2013D and B\u2013D) Series simplification (via B) Final parallel merge (A\u2013C) Every step was verified by graphical visualization.","title":"\ud83d\udcca Observations and Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#frequently-asked-questions-faq","text":"","title":"\u2753 Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#what-if-the-graph-contains-cycles-like-bridges","text":"You\u2019ll need \u0394\u2013Y (Delta\u2013Wye) transformations to handle those cases, not covered here.","title":"\ud83d\udca1 What if the graph contains cycles like bridges?"},{"location":"1%20Physics/5%20Circuits/Problem_1/#can-this-scale-to-10-node-graphs","text":"Yes, but you should implement auto-detection of series/parallel edges and recursion.","title":"\ud83d\udca1 Can this scale to 10+ node graphs?"},{"location":"1%20Physics/5%20Circuits/Problem_1/#does-the-order-of-reductions-matter","text":"In most linear cases, no. But for non-trivial topologies, correct detection is essential.","title":"\ud83d\udca1 Does the order of reductions matter?"},{"location":"1%20Physics/5%20Circuits/Problem_1/#how-do-i-extend-this-to-symbolic-unknown-resistors","text":"Use sympy and symbolic matrices instead of numerical weights. Visit Colab","title":"\ud83d\udca1 How do I extend this to symbolic (unknown) resistors?"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"\ud83d\udcca Central Limit Theorem \u2014 Simulation & Visualization in Python \ud83c\udfaf Objective Demonstrate the Central Limit Theorem (CLT) through simulations on different population distributions and visualize how the distribution of the sample mean becomes normal as the sample size increases. \ud83d\udcd6 What is the Central Limit Theorem? The Central Limit Theorem (CLT) states: Even if a population is not normally distributed, the distribution of the sample means tends to be approximately normal if the sample size is sufficiently large. Why is this important? - It allows us to apply normal distribution logic in hypothesis testing. - It enables confidence interval estimation. - It justifies using z-scores and t-scores even when the original data isn't normal. \ud83d\udcd8 Formula for the standard error (spread of sample means): [ \\sigma_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}} ] \ud83e\uddea Step 1: Create and Summarize Populations We generate three populations to simulate: - Uniform Distribution : Every value between 0 and 1 is equally likely. - Exponential Distribution : Highly right-skewed, models waiting times. - Binomial Distribution : Discrete 0 or 1 (like success/failure), here with 10 trials and 0.5 probability. np.random.seed(42) N = 100_000 uniform_pop = np.random.uniform(0, 1, N) exponential_pop = np.random.exponential(scale=1.0, size=N) binomial_pop = np.random.binomial(n=10, p=0.5, size=N) # Print summary print(\"\\U0001F4CA Population Summary:\") for name, pop in zip([\"Uniform\", \"Exponential\", \"Binomial\"], [uniform_pop, exponential_pop, binomial_pop]): print(f\"\\n\u2192 {name} Distribution:\") print(f\" Mean : {np.mean(pop):.3f}\") print(f\" Variance : {np.var(pop):.3f}\") # Plot histograms of populations plt.figure(figsize=(15, 4)) for i, (title, data, color) in enumerate(zip( [\"Uniform\", \"Exponential\", \"Binomial\"], [uniform_pop, exponential_pop, binomial_pop], ['skyblue', 'orange', 'red'] )): plt.subplot(1, 3, i+1) plt.hist(data, bins=50, color=color) plt.title(f\"{title} Distribution\") plt.tight_layout() plt.show() \ud83d\udcca Population Summary: \u2192 Uniform Distribution: Mean : 0.499 Variance : 0.083 \u2192 Exponential Distribution: Mean : 1.005 Variance : 1.008 \u2192 Binomial Distribution: Mean : 5.004 Variance : 2.504 \ud83d\udcc8 Step 2: Sampling and Distribution of Sample Means This function: - Takes multiple samples from a population - Computes the sample means - Plots the histogram of the means def plot_sampling_distribution(population, dist_name, color): sample_sizes = [5, 10, 30, 50] num_samples = 1000 plt.figure(figsize=(12, 8)) for i, n in enumerate(sample_sizes): sample_means = [ np.mean(np.random.choice(population, size=n, replace=False)) for _ in range(num_samples) ] plt.subplot(2, 2, i+1) sns.histplot(sample_means, kde=True, bins=30, color=color) plt.title(f\"{dist_name} \u2014 Sample Size {n}\", fontsize=12) plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(f\"CLT Sampling Distribution \u2014 {dist_name}\", fontsize=16, weight=\"bold\") plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show() \ud83d\udd2c Step 3: Simulation Results by Distribution \u25b6\ufe0f Uniform Distribution plot_sampling_distribution(uniform_pop, \"Uniform Distribution\", color=\"skyblue\") \ud83d\udcd8 Uniform Distribution: All values between 0 and 1 are equally likely. The population is flat. \ud83e\udde0 Observation: Despite the flat shape of the population, the sampling distribution becomes bell-shaped as the sample size increases. \u25b6\ufe0f Exponential Distribution plot_sampling_distribution(exponential_pop, \"Exponential Distribution\", color=\"orange\") \ud83d\udcd8 Exponential Distribution: Right-skewed, often used to model time between rare events. \ud83e\udde0 Observation: Initially skewed, but the sampling mean distribution becomes symmetric and normal-looking with larger samples. \u25b6\ufe0f Binomial Distribution plot_sampling_distribution(binomial_pop, \"Binomial Distribution\", color=\"red\") \ud83d\udcd8 Binomial Distribution: Discrete distribution, modeling the number of successes in a series of Bernoulli trials. \ud83e\udde0 Observation: Even a discrete distribution like binomial approaches a normal distribution in its sample means. \ud83d\udcc9 Step 4: Variance of the Sample Mean vs Sample Size The variance of the sample mean decreases as sample size increases: sizes = np.arange(1, 101) uniform_var = np.var(uniform_pop) variances = [uniform_var / n for n in sizes] plt.figure(figsize=(8,5)) plt.plot(sizes, variances, label='Var(X\u0304) = \u03c3\u00b2/n', color='green') plt.xlabel('Sample Size (n)') plt.ylabel('Variance of Sample Mean') plt.title('Variance Decreases as Sample Size Increases') plt.legend() plt.grid(True) plt.show() \ud83d\udcd8 Key Formula: [ \\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n} ] As sample size increases, the spread of the sample mean distribution shrinks , making estimates more precise. \ud83d\udcbc Real-World Applications of CLT Application Description Polling Estimate election results from survey samples. Quality Control Monitor product consistency in factories. Finance Predict average portfolio returns. Medicine Evaluate treatment effectiveness across sample groups. Tech A/B Testing Assess conversion rates between web design variations. \u2705 Conclusion CLT is powerful because it works with any distribution . Larger sample sizes make the sampling distribution more normal . This is why normal distribution is so common in real data. \ud83e\udde0 Key Takeaways CLT justifies statistical inference in real life. Sample size plays a critical role in normality of sample means . Visualization helps understand abstract statistical laws. Visit Colab","title":"\ud83d\udcca Central Limit Theorem \u2014 Simulation &amp; Visualization in Python"},{"location":"1%20Physics/6%20Statistics/Problem_1/#central-limit-theorem-simulation-visualization-in-python","text":"","title":"\ud83d\udcca Central Limit Theorem \u2014 Simulation &amp; Visualization in Python"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"Demonstrate the Central Limit Theorem (CLT) through simulations on different population distributions and visualize how the distribution of the sample mean becomes normal as the sample size increases.","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#what-is-the-central-limit-theorem","text":"The Central Limit Theorem (CLT) states: Even if a population is not normally distributed, the distribution of the sample means tends to be approximately normal if the sample size is sufficiently large. Why is this important? - It allows us to apply normal distribution logic in hypothesis testing. - It enables confidence interval estimation. - It justifies using z-scores and t-scores even when the original data isn't normal. \ud83d\udcd8 Formula for the standard error (spread of sample means): [ \\sigma_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}} ]","title":"\ud83d\udcd6 What is the Central Limit Theorem?"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-1-create-and-summarize-populations","text":"We generate three populations to simulate: - Uniform Distribution : Every value between 0 and 1 is equally likely. - Exponential Distribution : Highly right-skewed, models waiting times. - Binomial Distribution : Discrete 0 or 1 (like success/failure), here with 10 trials and 0.5 probability. np.random.seed(42) N = 100_000 uniform_pop = np.random.uniform(0, 1, N) exponential_pop = np.random.exponential(scale=1.0, size=N) binomial_pop = np.random.binomial(n=10, p=0.5, size=N) # Print summary print(\"\\U0001F4CA Population Summary:\") for name, pop in zip([\"Uniform\", \"Exponential\", \"Binomial\"], [uniform_pop, exponential_pop, binomial_pop]): print(f\"\\n\u2192 {name} Distribution:\") print(f\" Mean : {np.mean(pop):.3f}\") print(f\" Variance : {np.var(pop):.3f}\") # Plot histograms of populations plt.figure(figsize=(15, 4)) for i, (title, data, color) in enumerate(zip( [\"Uniform\", \"Exponential\", \"Binomial\"], [uniform_pop, exponential_pop, binomial_pop], ['skyblue', 'orange', 'red'] )): plt.subplot(1, 3, i+1) plt.hist(data, bins=50, color=color) plt.title(f\"{title} Distribution\") plt.tight_layout() plt.show() \ud83d\udcca Population Summary: \u2192 Uniform Distribution: Mean : 0.499 Variance : 0.083 \u2192 Exponential Distribution: Mean : 1.005 Variance : 1.008 \u2192 Binomial Distribution: Mean : 5.004 Variance : 2.504","title":"\ud83e\uddea Step 1: Create and Summarize Populations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-2-sampling-and-distribution-of-sample-means","text":"This function: - Takes multiple samples from a population - Computes the sample means - Plots the histogram of the means def plot_sampling_distribution(population, dist_name, color): sample_sizes = [5, 10, 30, 50] num_samples = 1000 plt.figure(figsize=(12, 8)) for i, n in enumerate(sample_sizes): sample_means = [ np.mean(np.random.choice(population, size=n, replace=False)) for _ in range(num_samples) ] plt.subplot(2, 2, i+1) sns.histplot(sample_means, kde=True, bins=30, color=color) plt.title(f\"{dist_name} \u2014 Sample Size {n}\", fontsize=12) plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(f\"CLT Sampling Distribution \u2014 {dist_name}\", fontsize=16, weight=\"bold\") plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show()","title":"\ud83d\udcc8 Step 2: Sampling and Distribution of Sample Means"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-3-simulation-results-by-distribution","text":"","title":"\ud83d\udd2c Step 3: Simulation Results by Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#uniform-distribution","text":"plot_sampling_distribution(uniform_pop, \"Uniform Distribution\", color=\"skyblue\") \ud83d\udcd8 Uniform Distribution: All values between 0 and 1 are equally likely. The population is flat. \ud83e\udde0 Observation: Despite the flat shape of the population, the sampling distribution becomes bell-shaped as the sample size increases.","title":"\u25b6\ufe0f Uniform Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exponential-distribution","text":"plot_sampling_distribution(exponential_pop, \"Exponential Distribution\", color=\"orange\") \ud83d\udcd8 Exponential Distribution: Right-skewed, often used to model time between rare events. \ud83e\udde0 Observation: Initially skewed, but the sampling mean distribution becomes symmetric and normal-looking with larger samples.","title":"\u25b6\ufe0f Exponential Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#binomial-distribution","text":"plot_sampling_distribution(binomial_pop, \"Binomial Distribution\", color=\"red\") \ud83d\udcd8 Binomial Distribution: Discrete distribution, modeling the number of successes in a series of Bernoulli trials. \ud83e\udde0 Observation: Even a discrete distribution like binomial approaches a normal distribution in its sample means.","title":"\u25b6\ufe0f Binomial Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-4-variance-of-the-sample-mean-vs-sample-size","text":"The variance of the sample mean decreases as sample size increases: sizes = np.arange(1, 101) uniform_var = np.var(uniform_pop) variances = [uniform_var / n for n in sizes] plt.figure(figsize=(8,5)) plt.plot(sizes, variances, label='Var(X\u0304) = \u03c3\u00b2/n', color='green') plt.xlabel('Sample Size (n)') plt.ylabel('Variance of Sample Mean') plt.title('Variance Decreases as Sample Size Increases') plt.legend() plt.grid(True) plt.show() \ud83d\udcd8 Key Formula: [ \\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n} ] As sample size increases, the spread of the sample mean distribution shrinks , making estimates more precise.","title":"\ud83d\udcc9 Step 4: Variance of the Sample Mean vs Sample Size"},{"location":"1%20Physics/6%20Statistics/Problem_1/#real-world-applications-of-clt","text":"Application Description Polling Estimate election results from survey samples. Quality Control Monitor product consistency in factories. Finance Predict average portfolio returns. Medicine Evaluate treatment effectiveness across sample groups. Tech A/B Testing Assess conversion rates between web design variations.","title":"\ud83d\udcbc Real-World Applications of CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"CLT is powerful because it works with any distribution . Larger sample sizes make the sampling distribution more normal . This is why normal distribution is so common in real data.","title":"\u2705 Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-takeaways","text":"CLT justifies statistical inference in real life. Sample size plays a critical role in normality of sample means . Visualization helps understand abstract statistical laws. Visit Colab","title":"\ud83e\udde0 Key Takeaways"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"\ud83c\udfaf Problem 2: Estimating Pi using Monte Carlo Methods \ud83d\udccc Part 1: Estimating Pi using a Circle \ud83d\udcd6 Theoretical Foundation The idea is based on the ratio of areas: - A unit circle has radius 1, so its area is \\( \\pi r^2 = \\pi \\) . - A square bounding this circle (from -1 to 1 in x and y) has area 4. If we randomly throw points into the square, the ratio of points that fall inside the circle will be approximately equal to the ratio of the areas: \\[ \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\approx \\frac{\\pi}{4} \\Rightarrow \\pi \\approx 4 \\cdot \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\] \ud83d\udc0d Python Code \u2013 Simulation and Visualization import numpy as np import matplotlib.pyplot as plt # Set random seed np.random.seed(42) # Function to estimate Pi and visualize def estimate_pi(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) distances = x**2 + y**2 inside = distances <= 1 pi_estimate = 4 * np.sum(inside) / num_points # Visualization plt.figure(figsize=(6,6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') plt.gca().set_aspect('equal') plt.title(f\"Monte Carlo Pi Estimate (n={num_points})\\nEstimated Pi \u2248 {pi_estimate:.5f}\") plt.legend() plt.grid(True) plt.show() return pi_estimate \u25b6\ufe0f Example: Estimating Pi with 10,000 points estimate_pi(10000) \ud83d\udcca Part 1 Analysis \u2013 Convergence of Estimation We now check how the estimate improves with more points. sample_sizes = [100, 1000, 5000, 10000, 50000, 100000, 500000] pi_estimates = [estimate_pi(n) for n in sample_sizes] plt.figure(figsize=(10,5)) plt.plot(sample_sizes, pi_estimates, marker='o', linestyle='-', label='Estimated Pi') plt.axhline(np.pi, color='green', linestyle='--', label='Actual Pi') plt.xscale('log') plt.xlabel('Number of Points (log scale)') plt.ylabel('Estimated Pi') plt.title('Convergence of Pi Estimation using Monte Carlo') plt.legend() plt.grid(True) plt.show() \ud83e\udde0 Observation: - The more points we use, the closer we get to the true value of \\( \\pi \\) . - However, convergence is slow \u2013 doubling the number of points gives marginal improvement. \ud83d\udccc Part 2: Estimating Pi using Buffon's Needle \ud83d\udcd6 Theoretical Foundation Buffon's Needle is a probability problem involving dropping a needle of length \\( L \\) onto a floor with parallel lines spaced distance \\( D \\) apart ( \\( L \\leq D \\) ). The probability that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi D} \\Rightarrow \\pi \\approx \\frac{2L \\cdot N}{D \\cdot H} \\] Where: - \\( N \\) : number of throws - \\( H \\) : number of hits (needle crosses a line) \ud83d\udc0d Python Code \u2013 Buffon\u2019s Needle Simulation def buffon_needle_simulation(N, L=1.0, D=2.0): hits = 0 x_positions = [] angles = [] crossed = [] for _ in range(N): x_center = np.random.uniform(0, D/2) angle = np.random.uniform(0, np.pi/2) x_positions.append(x_center) angles.append(angle) if x_center <= (L/2) * np.sin(angle): hits += 1 crossed.append(True) else: crossed.append(False) if hits == 0: return None # Avoid division by zero pi_estimate = (2 * L * N) / (D * hits) # Visualization plt.figure(figsize=(8, 6)) for i in range(N): x = x_positions[i] theta = angles[i] x0 = x - (L/2) * np.cos(theta) x1 = x + (L/2) * np.cos(theta) y0 = i % 50 y1 = y0 + np.sin(theta) * L color = 'red' if crossed[i] else 'gray' plt.plot([x0, x1], [y0, y1], color=color, linewidth=0.8) for line in np.arange(0, 10, D): plt.axvline(line, color='black', linestyle='--', alpha=0.4) plt.title(f\"Buffon's Needle Simulation (N={N})\\nEstimated Pi \u2248 {pi_estimate:.5f}\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.show() return pi_estimate \u25b6\ufe0f Example: Estimating Pi with Buffon's Needle buffon_needle_simulation(5000) \ud83d\udcca Part 2 Analysis \u2013 Convergence of Estimation sample_sizes = [100, 500, 1000, 5000, 10000, 20000] needle_estimates = [buffon_needle_simulation(n) for n in sample_sizes] plt.figure(figsize=(10,5)) plt.plot(sample_sizes, needle_estimates, marker='o', linestyle='-', label=\"Estimated Pi\") plt.axhline(np.pi, color='green', linestyle='--', label='Actual Pi') plt.xlabel(\"Number of Needle Drops\") plt.ylabel(\"Estimated Pi\") plt.title(\"Convergence of Pi Estimation via Buffon's Needle\") plt.legend() plt.grid(True) plt.show() \ud83e\udde0 Observation: - Buffon\u2019s method is elegant but noisier . - Requires significantly more simulations for stable convergence. \u2696\ufe0f Comparison: Circle vs Buffon\u2019s Needle Method Convergence Speed Visual Clarity Complexity Circle-based Faster High Simple Buffon\u2019s Needle Slower Medium Moderate \ud83d\udd0d Insight: Monte Carlo methods offer multiple paths to estimate \\( \\pi \\) , each with trade-offs. \u2705 Conclusion Monte Carlo simulations are a powerful tool in computational mathematics. Randomness can solve deterministic problems with elegance and insight . Both circle-based and Buffon\u2019s methods demonstrate convergence to \\( \\pi \\) , showcasing geometry + probability. Visit Colab","title":"\ud83c\udfaf Problem 2: Estimating Pi using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2-estimating-pi-using-monte-carlo-methods","text":"","title":"\ud83c\udfaf Problem 2: Estimating Pi using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-pi-using-a-circle","text":"","title":"\ud83d\udccc Part 1: Estimating Pi using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"The idea is based on the ratio of areas: - A unit circle has radius 1, so its area is \\( \\pi r^2 = \\pi \\) . - A square bounding this circle (from -1 to 1 in x and y) has area 4. If we randomly throw points into the square, the ratio of points that fall inside the circle will be approximately equal to the ratio of the areas: \\[ \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\approx \\frac{\\pi}{4} \\Rightarrow \\pi \\approx 4 \\cdot \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\]","title":"\ud83d\udcd6 Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-code-simulation-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt # Set random seed np.random.seed(42) # Function to estimate Pi and visualize def estimate_pi(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) distances = x**2 + y**2 inside = distances <= 1 pi_estimate = 4 * np.sum(inside) / num_points # Visualization plt.figure(figsize=(6,6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') plt.gca().set_aspect('equal') plt.title(f\"Monte Carlo Pi Estimate (n={num_points})\\nEstimated Pi \u2248 {pi_estimate:.5f}\") plt.legend() plt.grid(True) plt.show() return pi_estimate","title":"\ud83d\udc0d Python Code \u2013 Simulation and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#example-estimating-pi-with-10000-points","text":"estimate_pi(10000)","title":"\u25b6\ufe0f Example: Estimating Pi with 10,000 points"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-analysis-convergence-of-estimation","text":"We now check how the estimate improves with more points. sample_sizes = [100, 1000, 5000, 10000, 50000, 100000, 500000] pi_estimates = [estimate_pi(n) for n in sample_sizes] plt.figure(figsize=(10,5)) plt.plot(sample_sizes, pi_estimates, marker='o', linestyle='-', label='Estimated Pi') plt.axhline(np.pi, color='green', linestyle='--', label='Actual Pi') plt.xscale('log') plt.xlabel('Number of Points (log scale)') plt.ylabel('Estimated Pi') plt.title('Convergence of Pi Estimation using Monte Carlo') plt.legend() plt.grid(True) plt.show() \ud83e\udde0 Observation: - The more points we use, the closer we get to the true value of \\( \\pi \\) . - However, convergence is slow \u2013 doubling the number of points gives marginal improvement.","title":"\ud83d\udcca Part 1 Analysis \u2013 Convergence of Estimation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-pi-using-buffons-needle","text":"","title":"\ud83d\udccc Part 2: Estimating Pi using Buffon's Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"Buffon's Needle is a probability problem involving dropping a needle of length \\( L \\) onto a floor with parallel lines spaced distance \\( D \\) apart ( \\( L \\leq D \\) ). The probability that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi D} \\Rightarrow \\pi \\approx \\frac{2L \\cdot N}{D \\cdot H} \\] Where: - \\( N \\) : number of throws - \\( H \\) : number of hits (needle crosses a line)","title":"\ud83d\udcd6 Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-code-buffons-needle-simulation","text":"def buffon_needle_simulation(N, L=1.0, D=2.0): hits = 0 x_positions = [] angles = [] crossed = [] for _ in range(N): x_center = np.random.uniform(0, D/2) angle = np.random.uniform(0, np.pi/2) x_positions.append(x_center) angles.append(angle) if x_center <= (L/2) * np.sin(angle): hits += 1 crossed.append(True) else: crossed.append(False) if hits == 0: return None # Avoid division by zero pi_estimate = (2 * L * N) / (D * hits) # Visualization plt.figure(figsize=(8, 6)) for i in range(N): x = x_positions[i] theta = angles[i] x0 = x - (L/2) * np.cos(theta) x1 = x + (L/2) * np.cos(theta) y0 = i % 50 y1 = y0 + np.sin(theta) * L color = 'red' if crossed[i] else 'gray' plt.plot([x0, x1], [y0, y1], color=color, linewidth=0.8) for line in np.arange(0, 10, D): plt.axvline(line, color='black', linestyle='--', alpha=0.4) plt.title(f\"Buffon's Needle Simulation (N={N})\\nEstimated Pi \u2248 {pi_estimate:.5f}\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.show() return pi_estimate","title":"\ud83d\udc0d Python Code \u2013 Buffon\u2019s Needle Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#example-estimating-pi-with-buffons-needle","text":"buffon_needle_simulation(5000)","title":"\u25b6\ufe0f Example: Estimating Pi with Buffon's Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-analysis-convergence-of-estimation","text":"sample_sizes = [100, 500, 1000, 5000, 10000, 20000] needle_estimates = [buffon_needle_simulation(n) for n in sample_sizes] plt.figure(figsize=(10,5)) plt.plot(sample_sizes, needle_estimates, marker='o', linestyle='-', label=\"Estimated Pi\") plt.axhline(np.pi, color='green', linestyle='--', label='Actual Pi') plt.xlabel(\"Number of Needle Drops\") plt.ylabel(\"Estimated Pi\") plt.title(\"Convergence of Pi Estimation via Buffon's Needle\") plt.legend() plt.grid(True) plt.show() \ud83e\udde0 Observation: - Buffon\u2019s method is elegant but noisier . - Requires significantly more simulations for stable convergence.","title":"\ud83d\udcca Part 2 Analysis \u2013 Convergence of Estimation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-circle-vs-buffons-needle","text":"Method Convergence Speed Visual Clarity Complexity Circle-based Faster High Simple Buffon\u2019s Needle Slower Medium Moderate \ud83d\udd0d Insight: Monte Carlo methods offer multiple paths to estimate \\( \\pi \\) , each with trade-offs.","title":"\u2696\ufe0f Comparison: Circle vs Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion","text":"Monte Carlo simulations are a powerful tool in computational mathematics. Randomness can solve deterministic problems with elegance and insight . Both circle-based and Buffon\u2019s methods demonstrate convergence to \\( \\pi \\) , showcasing geometry + probability. Visit Colab","title":"\u2705 Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"\ud83c\udf0d Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum \ud83d\udccc Objective Estimate the acceleration due to gravity (g) using a simple pendulum, and perform uncertainty analysis based on measurement errors. \ud83e\uddea Experimental Setup Materials Used: - String (1.20 meters long) - Small metallic weight - Stopwatch with 0.01s resolution - Ruler with 0.01m resolution # Pendulum Length and Uncertainty L = 1.20 # meters L_resolution = 0.01 # meters L_uncertainty = L_resolution / 2 # \u00b10.005 m \u23f1\ufe0f Time Measurements for 10 Oscillations We performed 10 measurements of the time for 10 full oscillations: import numpy as np import matplotlib.pyplot as plt from math import pi from IPython.display import Markdown # Raw measurements in seconds measurements = np.array([22.51, 22.48, 22.52, 22.53, 22.49, 22.50, 22.47, 22.54, 22.48, 22.51]) # Calculations T10_mean = np.mean(measurements) # Average of 10 swings T10_std = np.std(measurements, ddof=1) # Standard deviation T_mean = T10_mean / 10 # Period of one swing T_uncertainty = T10_std / (10 * np.sqrt(len(measurements))) print(f\"Mean of 10 swings: {T10_mean:.3f} s\") print(f\"Standard deviation: {T10_std:.3f} s\") print(f\"Mean period (T): {T_mean:.4f} s \u00b1 {T_uncertainty:.4f} s\") Mean of 10 swings: 22.503 s Standard deviation: 0.023 s Mean period (T): 2.2503 s \u00b1 0.0007 s \ud83d\udcc8 Graph 1: Distribution of \\(T_{10}\\) Measurements plt.figure(figsize=(8, 4)) plt.hist(measurements, bins=8, color='skyblue', edgecolor='black') plt.axvline(T10_mean, color='red', linestyle='--', label='Mean') plt.title(\"Distribution of 10-Oscillation Times\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Frequency\") plt.legend() plt.grid(True) plt.show() \ud83d\udcc8 Graph 2: Time vs Trial Visualization plt.figure(figsize=(8, 4)) plt.plot(range(1, 11), measurements, marker='o', linestyle='-', color='orange') plt.axhline(y=T10_mean, color='blue', linestyle='--', label=f'Mean = {T10_mean:.2f} s') plt.title(\"Time for 10 Oscillations \u2013 Trial-by-Trial\") plt.xlabel(\"Trial Number\") plt.ylabel(\"Time (s)\") plt.grid(True) plt.legend() plt.show() \ud83e\uddee Estimating Gravity (g) The formula to compute g is: [ g = \\frac{4\\pi^2 L}{T^2} ] g = (4 * pi**2 * L) / (T_mean**2) print(f\"Estimated g = {g:.4f} m/s\u00b2\") Estimated g = 9.3554 m/s\u00b2 \ud83d\udcc9 Uncertainty in g We propagate uncertainty using: [ \\left( \\frac{\\Delta g}{g} \\right)^2 = \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 ] delta_g_rel = np.sqrt((L_uncertainty / L)**2 + (2 * T_uncertainty / T_mean)**2) delta_g = g * delta_g_rel print(f\"Uncertainty in g = \u00b1{delta_g:.4f} m/s\u00b2\") Uncertainty in g = \u00b10.0395 m/s\u00b2 \ud83d\udcc8 Graph 3: Comparison with Standard Gravity plt.figure(figsize=(6, 5)) plt.errorbar(['Measured g'], [g], yerr=[delta_g], fmt='o', capsize=10, label=\"Measured\") plt.axhline(y=9.81, color='green', linestyle='--', label=\"Standard g (9.81 m/s\u00b2)\") plt.title(\"Comparison of Measured vs Standard g\") plt.ylabel(\"g (m/s\u00b2)\") plt.legend() plt.grid(True) plt.show() \ud83d\udcca Final Results Table Markdown(f\"\"\" | Quantity | Value | Uncertainty | Units | |-------------------|---------------|------------------|---------| | Length (L) | {L:.2f} | \u00b1{L_uncertainty:.3f} | m | | Period (T) | {T_mean:.4f} | \u00b1{T_uncertainty:.4f} | s | | Gravity (g) | {g:.4f} | \u00b1{delta_g:.4f} | m/s\u00b2 | \"\"\") \ud83d\udd0d Discussion Comparison with standard g = 9.81 m/s\u00b2 Difference is due to human error, air drag, and small angle approximations. Sources of Uncertainty: Stopwatch resolution and reaction delay Small sample size (only 10 trials) Slight misalignment or swinging in non-2D motion Improvement Suggestions: Use photogate sensors for timing Repeat with more trials Reduce amplitude for small-angle approximation validity \u2705 Conclusion This classical experiment demonstrates how fundamental constants can be measured using simple apparatus and statistical tools. Despite its simplicity, careful analysis shows how uncertainty impacts our estimate and why precision matters in experimental physics. Visit Colab","title":"\ud83c\udf0d Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1-measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"\ud83c\udf0d Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#objective","text":"Estimate the acceleration due to gravity (g) using a simple pendulum, and perform uncertainty analysis based on measurement errors.","title":"\ud83d\udccc Objective"},{"location":"1%20Physics/7%20Measurements/Problem_1/#experimental-setup","text":"Materials Used: - String (1.20 meters long) - Small metallic weight - Stopwatch with 0.01s resolution - Ruler with 0.01m resolution # Pendulum Length and Uncertainty L = 1.20 # meters L_resolution = 0.01 # meters L_uncertainty = L_resolution / 2 # \u00b10.005 m","title":"\ud83e\uddea Experimental Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#time-measurements-for-10-oscillations","text":"We performed 10 measurements of the time for 10 full oscillations: import numpy as np import matplotlib.pyplot as plt from math import pi from IPython.display import Markdown # Raw measurements in seconds measurements = np.array([22.51, 22.48, 22.52, 22.53, 22.49, 22.50, 22.47, 22.54, 22.48, 22.51]) # Calculations T10_mean = np.mean(measurements) # Average of 10 swings T10_std = np.std(measurements, ddof=1) # Standard deviation T_mean = T10_mean / 10 # Period of one swing T_uncertainty = T10_std / (10 * np.sqrt(len(measurements))) print(f\"Mean of 10 swings: {T10_mean:.3f} s\") print(f\"Standard deviation: {T10_std:.3f} s\") print(f\"Mean period (T): {T_mean:.4f} s \u00b1 {T_uncertainty:.4f} s\") Mean of 10 swings: 22.503 s Standard deviation: 0.023 s Mean period (T): 2.2503 s \u00b1 0.0007 s","title":"\u23f1\ufe0f Time Measurements for 10 Oscillations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#graph-1-distribution-of-t_10-measurements","text":"plt.figure(figsize=(8, 4)) plt.hist(measurements, bins=8, color='skyblue', edgecolor='black') plt.axvline(T10_mean, color='red', linestyle='--', label='Mean') plt.title(\"Distribution of 10-Oscillation Times\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Frequency\") plt.legend() plt.grid(True) plt.show()","title":"\ud83d\udcc8 Graph 1: Distribution of \\(T_{10}\\) Measurements"},{"location":"1%20Physics/7%20Measurements/Problem_1/#graph-2-time-vs-trial-visualization","text":"plt.figure(figsize=(8, 4)) plt.plot(range(1, 11), measurements, marker='o', linestyle='-', color='orange') plt.axhline(y=T10_mean, color='blue', linestyle='--', label=f'Mean = {T10_mean:.2f} s') plt.title(\"Time for 10 Oscillations \u2013 Trial-by-Trial\") plt.xlabel(\"Trial Number\") plt.ylabel(\"Time (s)\") plt.grid(True) plt.legend() plt.show()","title":"\ud83d\udcc8 Graph 2: Time vs Trial Visualization"},{"location":"1%20Physics/7%20Measurements/Problem_1/#estimating-gravity-g","text":"The formula to compute g is: [ g = \\frac{4\\pi^2 L}{T^2} ] g = (4 * pi**2 * L) / (T_mean**2) print(f\"Estimated g = {g:.4f} m/s\u00b2\") Estimated g = 9.3554 m/s\u00b2","title":"\ud83e\uddee Estimating Gravity (g)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-g","text":"We propagate uncertainty using: [ \\left( \\frac{\\Delta g}{g} \\right)^2 = \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 ] delta_g_rel = np.sqrt((L_uncertainty / L)**2 + (2 * T_uncertainty / T_mean)**2) delta_g = g * delta_g_rel print(f\"Uncertainty in g = \u00b1{delta_g:.4f} m/s\u00b2\") Uncertainty in g = \u00b10.0395 m/s\u00b2","title":"\ud83d\udcc9 Uncertainty in g"},{"location":"1%20Physics/7%20Measurements/Problem_1/#graph-3-comparison-with-standard-gravity","text":"plt.figure(figsize=(6, 5)) plt.errorbar(['Measured g'], [g], yerr=[delta_g], fmt='o', capsize=10, label=\"Measured\") plt.axhline(y=9.81, color='green', linestyle='--', label=\"Standard g (9.81 m/s\u00b2)\") plt.title(\"Comparison of Measured vs Standard g\") plt.ylabel(\"g (m/s\u00b2)\") plt.legend() plt.grid(True) plt.show()","title":"\ud83d\udcc8 Graph 3: Comparison with Standard Gravity"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-results-table","text":"Markdown(f\"\"\" | Quantity | Value | Uncertainty | Units | |-------------------|---------------|------------------|---------| | Length (L) | {L:.2f} | \u00b1{L_uncertainty:.3f} | m | | Period (T) | {T_mean:.4f} | \u00b1{T_uncertainty:.4f} | s | | Gravity (g) | {g:.4f} | \u00b1{delta_g:.4f} | m/s\u00b2 | \"\"\")","title":"\ud83d\udcca Final Results Table"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion","text":"Comparison with standard g = 9.81 m/s\u00b2 Difference is due to human error, air drag, and small angle approximations. Sources of Uncertainty: Stopwatch resolution and reaction delay Small sample size (only 10 trials) Slight misalignment or swinging in non-2D motion Improvement Suggestions: Use photogate sensors for timing Repeat with more trials Reduce amplitude for small-angle approximation validity","title":"\ud83d\udd0d Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"This classical experiment demonstrates how fundamental constants can be measured using simple apparatus and statistical tools. Despite its simplicity, careful analysis shows how uncertainty impacts our estimate and why precision matters in experimental physics. Visit Colab","title":"\u2705 Conclusion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}