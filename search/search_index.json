{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Problem 1: Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation 1.0 Starting from Newton's Second Law Projectile motion can be derived from Newton\u2019s Second Law: \\[ \\vec{F} = m \\vec{a} \\] In the absence of air resistance, the only force acting on the projectile is gravity, acting in the vertical direction: \\[ \\vec{a} = \\begin{bmatrix} 0 \\\\ -g \\end{bmatrix} \\] This leads to the second-order differential equations: Horizontal motion: \\[ \\frac{d^2x}{dt^2} = 0 \\Rightarrow \\frac{dx}{dt} = v_{0x} = v_0 \\cos(\\theta) \\Rightarrow x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion: \\[ \\frac{d^2y}{dt^2} = -g \\Rightarrow \\frac{dy}{dt} = v_0 \\sin(\\theta) - g t \\Rightarrow y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] These equations form the theoretical foundation of projectile motion and will be used to derive further quantities such as the time of flight, range, and trajectory. Projectile motion is a type of two-dimensional motion where an object is launched into the air with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) relative to the horizontal. The motion can be analyzed by breaking it into horizontal (x) and vertical (y) components. 1.1 Equations of Motion The horizontal and vertical components of the initial velocity are: \\[v_{0x} = v_0 \\cos(\\theta)\\] \\[v_{0y} = v_0 \\sin(\\theta)\\] Using the kinematic equations, the motion in each direction is governed by: Horizontal motion (constant velocity, no acceleration in the ideal case): \\[x = v_{0x} t = v_0 \\cos(\\theta) t\\] Vertical motion (accelerated due to gravity): \\[y = v_{0y} t - \\frac{1}{2} g t^2\\] where: \\(g\\) is the acceleration due to gravity \\((9.81 \\text{ m/s}^2)\\) \\(t\\) is the time of flight. 1.2 Time of Flight The time of flight is determined by solving for when the projectile returns to the ground \\((y = 0)\\) : \\( \\(t = \\frac{2 v_0 \\sin(\\theta)}{g}\\) \\) 1.3 Range Equation The range \\( \\(R\\) \\) is the horizontal distance traveled when the projectile lands: \\( \\(R = v_{0x} \\cdot t = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) \\) Using the identity \\( \\(2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) \\) , we get: \\( \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) \\) 2. Analysis of the Range The range is maximized when \\( \\(\\sin(2\\theta) = 1\\) \\) , which occurs at \\( \\(2\\theta = 90^\\circ\\) \\) , or \\( \\(\\theta = 45^\\circ\\) \\) . If the initial velocity \\( \\(v_0\\) \\) increases, the range increases quadratically. If gravity \\( \\(g\\) \\) increases (e.g., on another planet), the range decreases. 3. Practical Applications Sports: Understanding projectile motion is crucial in games like soccer, basketball, and golf. Engineering: Used in ballistics, rocketry, and artillery targeting systems. Real-World Effects: Air resistance, wind, and uneven terrain can significantly alter the theoretical range. 4. Implementation: Python Simulation The following Python script simulates projectile motion and plots the range as a function of the angle of projection. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0=20, g=9.81): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') max_range = (v0**2 * np.sin(np.radians(90))) / g plt.plot(45, max_range, 'ro') plt.annotate(f'Max: {max_range:.1f} m', xy=(45, max_range), xytext=(50, max_range + 5), arrowprops=dict(arrowstyle=\"->\")) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle (v\u2080 = 20 m/s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() projectile_range() Figure 1: Horizontal range vs. launch angle for a projectile with v\u2080 = 20 m/s. Maximum range occurs at 45\u00b0. Explanation of the Graph This graph illustrates how the horizontal range of a projectile depends on the launch angle for different initial velocities ( \\( v_0 \\) ). Each curve represents a different initial velocity. The maximum range occurs at 45\u00b0 . As the initial velocity increases, the range increases quadratically ( \\( v_0^2 \\) ) . Lower initial velocities result in shorter ranges, while higher velocities allow the projectile to travel further. This helps in understanding how objects like balls, bullets, or rockets behave when launched at different speeds and angles. \ud83d\ude80 import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_v0(v0_list, g=9.81): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) plt.figure(figsize=(8, 5)) for v0 in v0_list: ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') max_range = (v0**2 * np.sin(np.radians(90))) / g plt.plot(45, max_range, 'o') # Nokta koy plt.annotate(f'{max_range:.1f} m', xy=(45, max_range), xytext=(45, max_range + 2), fontsize=8) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different v\u2080\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() projectile_range_multi_v0([10, 20, 30, 40]) Figure 2: Horizontal range vs. launch angle for different initial velocities. Higher v\u2080 increases the range, and the maximum always occurs at 45\u00b0. Explanation of the Graph This graph shows how the horizontal range of a projectile changes with the launch angle for different gravitational accelerations ( \\(g\\) ). Each curve represents a different gravitational environment: Earth ( \\(g = 9.81 \\, \\text{m/s}^2\\) ), Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), and Jupiter ( \\(g = 24.79 \\, \\text{m/s}^2\\) ). As gravity decreases (like on the Moon), the range increases for the same initial velocity. On higher gravity bodies (like Jupiter), the range decreases. This graph helps understand how the same projectile behaves differently in various planetary environments. import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_g(v0=20, g_values=[9.81, 1.62, 24.79]): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) g_labels = [\"Earth (9.81 m/s\u00b2)\", \"Moon (1.62 m/s\u00b2)\", \"Jupiter (24.79 m/s\u00b2)\"] plt.figure(figsize=(8, 5)) for g, label in zip(g_values, g_labels): ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=label) max_range = (v0**2 * np.sin(np.radians(90))) / g plt.plot(45, max_range, 'o') plt.annotate(f'{max_range:.1f} m', xy=(45, max_range), xytext=(45, max_range + 2), fontsize=8) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different Gravities\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() projectile_range_multi_g() Figure 3: Horizontal range vs. launch angle under different gravitational accelerations. Lower gravity leads to longer ranges; maximum always at 45\u00b0. Explanation of the Graph This graph demonstrates how the initial height ( \\(y_0\\) ) affects the projectile's motion. Each curve represents a projectile launched from a different height. The higher the starting point, the longer the projectile stays in the air. Longer airtime results in a greater horizontal range . This effect is especially noticeable when launching from elevated positions (e.g., a cliff, a tower). This concept is useful in real-world scenarios like launching missiles from elevated platforms or analyzing sports trajectories like basketball shots from different angles. \ud83c\udfc0 import numpy as np import matplotlib.pyplot as plt def trajectory(v0, angle_deg, y0=0, g=9.81): angle_rad = np.radians(angle_deg) vy0 = v0 * np.sin(angle_rad) t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g t = np.linspace(0, t_flight, 500) x = v0 * np.cos(angle_rad) * t y = y0 + vy0 * t - 0.5 * g * t**2 return x, y v0 = 25 angle = 45 heights = [0, 10, 50] plt.figure(figsize=(10, 6)) for h in heights: x, y = trajectory(v0, angle, y0=h) plt.plot(x, y, label=f'Initial height = {h} m') plt.title(\"Projectile Motion from Different Heights (v\u2080 = 25 m/s, \u03b8 = 45\u00b0)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Figure 4: Trajectories of projectiles launched from different heights (0 m, 10 m, 50 m) at 45\u00b0 and 25 m/s. Explanation of the Graph This graph compares projectile motion with and without air resistance . The red curve shows the ideal case (no air resistance). The blue dashed curve includes air resistance. With air resistance, the projectile does not travel as far and has a flatter arc . The effect of air resistance becomes more noticeable at higher speeds. This comparison is essential in real-world applications like ballistics, sports, and aerospace engineering, where air drag cannot be ignored. \u2708\ufe0f import numpy as np import matplotlib.pyplot as plt def trajectory(v0, angle_deg, y0=0, g=9.81): angle_rad = np.radians(angle_deg) vy0 = v0 * np.sin(angle_rad) t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g t = np.linspace(0, t_flight, 500) x = v0 * np.cos(angle_rad) * t y = y0 + vy0 * t - 0.5 * g * t**2 return x, y def trajectory_with_air_resistance(v0, angle_deg, y0=0, g=9.81, k=0.05, dt=0.01): angle_rad = np.radians(angle_deg) vx = v0 * np.cos(angle_rad) vy = v0 * np.sin(angle_rad) x, y = 0, y0 X, Y = [x], [y] while y >= 0: ax = -k * vx ay = -g - k * vy vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt X.append(x) Y.append(y) return X, Y v0 = 25 angle = 45 x1, y1 = trajectory(v0, angle) x2, y2 = trajectory_with_air_resistance(v0, angle) plt.figure(figsize=(10, 6)) plt.plot(x1, y1, label='No Air Resistance', color='red') plt.plot(x2, y2, '--', label='With Air Resistance', color='blue') plt.title(\"Projectile Motion: With vs. Without Air Resistance (v\u2080 = 25 m/s, \u03b8 = 45\u00b0)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() Figure 5: Comparison of trajectories with and without air resistance. \ud83c\udfaf Trajectory Comparison for Different Launch Angles (v\u2080 = 25 m/s) This graph shows how the launch angle affects the trajectory shape and horizontal distance when the initial velocity is fixed at 25 m/s. All projectiles are launched from the same height and speed. Angles used: 15\u00b0, 39\u00b0, 45\u00b0, and 60\u00b0 The longest range is achieved at 45\u00b0 . Higher angles result in higher but shorter trajectories. import numpy as np import matplotlib.pyplot as plt def trajectory(v0, angle_deg, y0=0, g=9.81): angle_rad = np.radians(angle_deg) vy0 = v0 * np.sin(angle_rad) t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g t = np.linspace(0, t_flight, 500) x = v0 * np.cos(angle_rad) * t y = y0 + vy0 * t - 0.5 * g * t**2 return x, y # Parameters v0 = 25 angles = [15, 39, 45, 60] plt.figure(figsize=(10, 6)) for angle in angles: x, y = trajectory(v0, angle) plt.plot(x, y, label=f'{angle}\u00b0') plt.title(\"Projectile Trajectories at Different Angles (v\u2080 = 25 m/s)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Figure 6: Trajectories for different launch angles at fixed speed (v\u2080 = 25 m/s). 5. Frequently Asked Questions (FAQ) 1. At what angle is the maximum range achieved in projectile motion? The maximum range is achieved at 45\u00b0 because, at this angle, the horizontal and vertical components of the velocity are balanced, maximizing distance. 2. How does the initial velocity affect the range? The range increases quadratically (v\u2080\u00b2) as the initial velocity increases, meaning a faster launch gives the projectile more distance to travel. 3. What happens if gravity changes? A higher gravitational acceleration reduces the range because the projectile falls back to the ground more quickly, while a lower gravity increases the range by allowing the projectile to stay in the air longer. 4. Does mass affect the projectile's range? No, in ideal conditions without air resistance, mass does not affect the range because both heavy and light projectiles fall at the same rate under the same conditions. 5. How does air resistance impact projectile motion? Air resistance reduces the range by slowing down the projectile and changing its trajectory, making the optimal launch angle lower than 45\u00b0. \u2705 Checklist: Teacher's Suggestions Implemented Suggestion Status Location in Project 3 different velocities (v\u2080) at same angle, showing range comparison \u2714\ufe0f Done Figure 2 \u2013 projectile_range_multi_v0 3 different planets (different gravity values) with same initial velocity \u2714\ufe0f Done Figure 3 \u2013 projectile_range_multi_g Launching from different heights \u2714\ufe0f Done Figure 4 \u2013 heights = [0, 10, 50] Same speed with different angles (15\u00b0, 39\u00b0, 45\u00b0, 60\u00b0) \u2714\ufe0f Done Figure 6 \u2013 angles = [15, 39, 45, 60] Comparison between with and without air resistance \u2714\ufe0f Done Figure 5 \u2013 trajectory_with_air_resistance()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#10-starting-from-newtons-second-law","text":"Projectile motion can be derived from Newton\u2019s Second Law: \\[ \\vec{F} = m \\vec{a} \\] In the absence of air resistance, the only force acting on the projectile is gravity, acting in the vertical direction: \\[ \\vec{a} = \\begin{bmatrix} 0 \\\\ -g \\end{bmatrix} \\] This leads to the second-order differential equations: Horizontal motion: \\[ \\frac{d^2x}{dt^2} = 0 \\Rightarrow \\frac{dx}{dt} = v_{0x} = v_0 \\cos(\\theta) \\Rightarrow x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion: \\[ \\frac{d^2y}{dt^2} = -g \\Rightarrow \\frac{dy}{dt} = v_0 \\sin(\\theta) - g t \\Rightarrow y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] These equations form the theoretical foundation of projectile motion and will be used to derive further quantities such as the time of flight, range, and trajectory. Projectile motion is a type of two-dimensional motion where an object is launched into the air with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) relative to the horizontal. The motion can be analyzed by breaking it into horizontal (x) and vertical (y) components.","title":"1.0 Starting from Newton's Second Law"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion","text":"The horizontal and vertical components of the initial velocity are: \\[v_{0x} = v_0 \\cos(\\theta)\\] \\[v_{0y} = v_0 \\sin(\\theta)\\] Using the kinematic equations, the motion in each direction is governed by: Horizontal motion (constant velocity, no acceleration in the ideal case): \\[x = v_{0x} t = v_0 \\cos(\\theta) t\\] Vertical motion (accelerated due to gravity): \\[y = v_{0y} t - \\frac{1}{2} g t^2\\] where: \\(g\\) is the acceleration due to gravity \\((9.81 \\text{ m/s}^2)\\) \\(t\\) is the time of flight.","title":"1.1 Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"The time of flight is determined by solving for when the projectile returns to the ground \\((y = 0)\\) : \\( \\(t = \\frac{2 v_0 \\sin(\\theta)}{g}\\) \\)","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range-equation","text":"The range \\( \\(R\\) \\) is the horizontal distance traveled when the projectile lands: \\( \\(R = v_{0x} \\cdot t = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) \\) Using the identity \\( \\(2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) \\) , we get: \\( \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) \\)","title":"1.3 Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range is maximized when \\( \\(\\sin(2\\theta) = 1\\) \\) , which occurs at \\( \\(2\\theta = 90^\\circ\\) \\) , or \\( \\(\\theta = 45^\\circ\\) \\) . If the initial velocity \\( \\(v_0\\) \\) increases, the range increases quadratically. If gravity \\( \\(g\\) \\) increases (e.g., on another planet), the range decreases.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports: Understanding projectile motion is crucial in games like soccer, basketball, and golf. Engineering: Used in ballistics, rocketry, and artillery targeting systems. Real-World Effects: Air resistance, wind, and uneven terrain can significantly alter the theoretical range.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation","text":"The following Python script simulates projectile motion and plots the range as a function of the angle of projection. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0=20, g=9.81): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') max_range = (v0**2 * np.sin(np.radians(90))) / g plt.plot(45, max_range, 'ro') plt.annotate(f'Max: {max_range:.1f} m', xy=(45, max_range), xytext=(50, max_range + 5), arrowprops=dict(arrowstyle=\"->\")) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle (v\u2080 = 20 m/s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() projectile_range() Figure 1: Horizontal range vs. launch angle for a projectile with v\u2080 = 20 m/s. Maximum range occurs at 45\u00b0.","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-graph","text":"This graph illustrates how the horizontal range of a projectile depends on the launch angle for different initial velocities ( \\( v_0 \\) ). Each curve represents a different initial velocity. The maximum range occurs at 45\u00b0 . As the initial velocity increases, the range increases quadratically ( \\( v_0^2 \\) ) . Lower initial velocities result in shorter ranges, while higher velocities allow the projectile to travel further. This helps in understanding how objects like balls, bullets, or rockets behave when launched at different speeds and angles. \ud83d\ude80 import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_v0(v0_list, g=9.81): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) plt.figure(figsize=(8, 5)) for v0 in v0_list: ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') max_range = (v0**2 * np.sin(np.radians(90))) / g plt.plot(45, max_range, 'o') # Nokta koy plt.annotate(f'{max_range:.1f} m', xy=(45, max_range), xytext=(45, max_range + 2), fontsize=8) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different v\u2080\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() projectile_range_multi_v0([10, 20, 30, 40]) Figure 2: Horizontal range vs. launch angle for different initial velocities. Higher v\u2080 increases the range, and the maximum always occurs at 45\u00b0.","title":"Explanation of the Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-graph_1","text":"This graph shows how the horizontal range of a projectile changes with the launch angle for different gravitational accelerations ( \\(g\\) ). Each curve represents a different gravitational environment: Earth ( \\(g = 9.81 \\, \\text{m/s}^2\\) ), Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), and Jupiter ( \\(g = 24.79 \\, \\text{m/s}^2\\) ). As gravity decreases (like on the Moon), the range increases for the same initial velocity. On higher gravity bodies (like Jupiter), the range decreases. This graph helps understand how the same projectile behaves differently in various planetary environments. import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_g(v0=20, g_values=[9.81, 1.62, 24.79]): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) g_labels = [\"Earth (9.81 m/s\u00b2)\", \"Moon (1.62 m/s\u00b2)\", \"Jupiter (24.79 m/s\u00b2)\"] plt.figure(figsize=(8, 5)) for g, label in zip(g_values, g_labels): ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=label) max_range = (v0**2 * np.sin(np.radians(90))) / g plt.plot(45, max_range, 'o') plt.annotate(f'{max_range:.1f} m', xy=(45, max_range), xytext=(45, max_range + 2), fontsize=8) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different Gravities\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() projectile_range_multi_g() Figure 3: Horizontal range vs. launch angle under different gravitational accelerations. Lower gravity leads to longer ranges; maximum always at 45\u00b0.","title":"Explanation of the Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-graph_2","text":"This graph demonstrates how the initial height ( \\(y_0\\) ) affects the projectile's motion. Each curve represents a projectile launched from a different height. The higher the starting point, the longer the projectile stays in the air. Longer airtime results in a greater horizontal range . This effect is especially noticeable when launching from elevated positions (e.g., a cliff, a tower). This concept is useful in real-world scenarios like launching missiles from elevated platforms or analyzing sports trajectories like basketball shots from different angles. \ud83c\udfc0 import numpy as np import matplotlib.pyplot as plt def trajectory(v0, angle_deg, y0=0, g=9.81): angle_rad = np.radians(angle_deg) vy0 = v0 * np.sin(angle_rad) t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g t = np.linspace(0, t_flight, 500) x = v0 * np.cos(angle_rad) * t y = y0 + vy0 * t - 0.5 * g * t**2 return x, y v0 = 25 angle = 45 heights = [0, 10, 50] plt.figure(figsize=(10, 6)) for h in heights: x, y = trajectory(v0, angle, y0=h) plt.plot(x, y, label=f'Initial height = {h} m') plt.title(\"Projectile Motion from Different Heights (v\u2080 = 25 m/s, \u03b8 = 45\u00b0)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Figure 4: Trajectories of projectiles launched from different heights (0 m, 10 m, 50 m) at 45\u00b0 and 25 m/s.","title":"Explanation of the Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-graph_3","text":"This graph compares projectile motion with and without air resistance . The red curve shows the ideal case (no air resistance). The blue dashed curve includes air resistance. With air resistance, the projectile does not travel as far and has a flatter arc . The effect of air resistance becomes more noticeable at higher speeds. This comparison is essential in real-world applications like ballistics, sports, and aerospace engineering, where air drag cannot be ignored. \u2708\ufe0f import numpy as np import matplotlib.pyplot as plt def trajectory(v0, angle_deg, y0=0, g=9.81): angle_rad = np.radians(angle_deg) vy0 = v0 * np.sin(angle_rad) t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g t = np.linspace(0, t_flight, 500) x = v0 * np.cos(angle_rad) * t y = y0 + vy0 * t - 0.5 * g * t**2 return x, y def trajectory_with_air_resistance(v0, angle_deg, y0=0, g=9.81, k=0.05, dt=0.01): angle_rad = np.radians(angle_deg) vx = v0 * np.cos(angle_rad) vy = v0 * np.sin(angle_rad) x, y = 0, y0 X, Y = [x], [y] while y >= 0: ax = -k * vx ay = -g - k * vy vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt X.append(x) Y.append(y) return X, Y v0 = 25 angle = 45 x1, y1 = trajectory(v0, angle) x2, y2 = trajectory_with_air_resistance(v0, angle) plt.figure(figsize=(10, 6)) plt.plot(x1, y1, label='No Air Resistance', color='red') plt.plot(x2, y2, '--', label='With Air Resistance', color='blue') plt.title(\"Projectile Motion: With vs. Without Air Resistance (v\u2080 = 25 m/s, \u03b8 = 45\u00b0)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() Figure 5: Comparison of trajectories with and without air resistance.","title":"Explanation of the Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#trajectory-comparison-for-different-launch-angles-v0-25-ms","text":"This graph shows how the launch angle affects the trajectory shape and horizontal distance when the initial velocity is fixed at 25 m/s. All projectiles are launched from the same height and speed. Angles used: 15\u00b0, 39\u00b0, 45\u00b0, and 60\u00b0 The longest range is achieved at 45\u00b0 . Higher angles result in higher but shorter trajectories. import numpy as np import matplotlib.pyplot as plt def trajectory(v0, angle_deg, y0=0, g=9.81): angle_rad = np.radians(angle_deg) vy0 = v0 * np.sin(angle_rad) t_flight = (vy0 + np.sqrt(vy0**2 + 2 * g * y0)) / g t = np.linspace(0, t_flight, 500) x = v0 * np.cos(angle_rad) * t y = y0 + vy0 * t - 0.5 * g * t**2 return x, y # Parameters v0 = 25 angles = [15, 39, 45, 60] plt.figure(figsize=(10, 6)) for angle in angles: x, y = trajectory(v0, angle) plt.plot(x, y, label=f'{angle}\u00b0') plt.title(\"Projectile Trajectories at Different Angles (v\u2080 = 25 m/s)\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Height (m)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Figure 6: Trajectories for different launch angles at fixed speed (v\u2080 = 25 m/s).","title":"\ud83c\udfaf Trajectory Comparison for Different Launch Angles (v\u2080 = 25 m/s)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-frequently-asked-questions-faq","text":"","title":"5. Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-at-what-angle-is-the-maximum-range-achieved-in-projectile-motion","text":"The maximum range is achieved at 45\u00b0 because, at this angle, the horizontal and vertical components of the velocity are balanced, maximizing distance.","title":"1. At what angle is the maximum range achieved in projectile motion?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-how-does-the-initial-velocity-affect-the-range","text":"The range increases quadratically (v\u2080\u00b2) as the initial velocity increases, meaning a faster launch gives the projectile more distance to travel.","title":"2. How does the initial velocity affect the range?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-what-happens-if-gravity-changes","text":"A higher gravitational acceleration reduces the range because the projectile falls back to the ground more quickly, while a lower gravity increases the range by allowing the projectile to stay in the air longer.","title":"3. What happens if gravity changes?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-does-mass-affect-the-projectiles-range","text":"No, in ideal conditions without air resistance, mass does not affect the range because both heavy and light projectiles fall at the same rate under the same conditions.","title":"4. Does mass affect the projectile's range?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-how-does-air-resistance-impact-projectile-motion","text":"Air resistance reduces the range by slowing down the projectile and changing its trajectory, making the optimal launch angle lower than 45\u00b0.","title":"5. How does air resistance impact projectile motion?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#checklist-teachers-suggestions-implemented","text":"Suggestion Status Location in Project 3 different velocities (v\u2080) at same angle, showing range comparison \u2714\ufe0f Done Figure 2 \u2013 projectile_range_multi_v0 3 different planets (different gravity values) with same initial velocity \u2714\ufe0f Done Figure 3 \u2013 projectile_range_multi_g Launching from different heights \u2714\ufe0f Done Figure 4 \u2013 heights = [0, 10, 50] Same speed with different angles (15\u00b0, 39\u00b0, 45\u00b0, 60\u00b0) \u2714\ufe0f Done Figure 6 \u2013 angles = [15, 39, 45, 60] Comparison between with and without air resistance \u2714\ufe0f Done Figure 5 \u2013 trajectory_with_air_resistance()","title":"\u2705 Checklist: Teacher's Suggestions Implemented"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a classic example of nonlinear dynamics. Unlike simple harmonic oscillators, this system responds to periodic external forces and damping, producing rich behavior that includes resonance, synchronization, and even chaos. This kind of system is fundamental in physics and engineering because it mirrors the behavior of real-world systems like suspension bridges, circuits, and mechanical vibration absorbers. 1. Theoretical Foundation The general nonlinear equation for the forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement (radians) - \\(\\gamma\\) : damping coefficient (how quickly oscillations die out) - \\(\\omega_0\\) : natural angular frequency ( \\(\\omega_0 = \\sqrt{g / L}\\) for a pendulum of length \\(L\\) ) - \\(A\\) : amplitude of external force - \\(\\omega\\) : driving frequency Small-Angle Approximation When \\(\\theta\\) is small (typically less than 10\u00b0), we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This form is a linear second-order ODE, easier to solve and useful for studying resonance behavior. 2. Python Simulation Let's simulate the pendulum using numerical methods. We'll use the Runge-Kutta method via scipy.integrate.solve_ivp . import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Differential equation def pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dydt = [omega_theta, -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Parameters gamma = 0.2 omega0 = 1.5 A = 1.2 omega_drive = 2.0 y0 = [0.1, 0.0] t_span = (0, 50) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) # Plot angle over time plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.grid(True) plt.legend() plt.show() 3. Phase Space (\u03b8 vs \u03c9) This plot helps visualize how the system evolves in state space. plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Space') plt.xlabel('Angle \u03b8 (rad)') plt.ylabel('Angular Velocity \u03c9 (rad/s)') plt.grid(True) plt.show() 4. Poincar\u00e9 Section The Poincar\u00e9 section samples the system once per driving cycle, helping identify periodicity and chaos. T = 2 * np.pi / omega_drive poincare_times = np.arange(0, t_span[1], T) poincare_points = [] for t_p in poincare_times: idx = np.argmin(np.abs(sol.t - t_p)) poincare_points.append([sol.y[0][idx] % (2*np.pi), sol.y[1][idx]]) poincare_points = np.array(poincare_points) plt.figure(figsize=(6, 6)) plt.scatter(poincare_points[:, 0], poincare_points[:, 1], s=10, color='crimson') plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 mod $2\\pi$ (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.grid(True) plt.show() 5. Additional Visualization: Energy Over Time Visualizing total mechanical energy shows how damping and driving force interact. mass = 1.0 length = 1.0 g = 9.81 theta = sol.y[0] omega = sol.y[1] potential_energy = mass * g * length * (1 - np.cos(theta)) kinetic_energy = 0.5 * mass * (length**2) * omega**2 total_energy = potential_energy + kinetic_energy plt.figure(figsize=(10, 4)) plt.plot(sol.t, total_energy) plt.title('Total Mechanical Energy vs Time') plt.xlabel('Time (s)') plt.ylabel('Energy (J)') plt.grid(True) plt.show() 6. Bifurcation Diagram Explore how the long-term behavior changes with the driving amplitude A. bifurcation_A = np.linspace(1.0, 1.5, 300) steady_states = [] for A_val in bifurcation_A: sol = solve_ivp(pendulum, [0, 200], [0.1, 0.0], t_eval=np.linspace(150, 200, 500), args=(gamma, omega0, A_val, omega_drive)) theta_vals = sol.y[0] % (2 * np.pi) steady_states.append((np.full_like(theta_vals, A_val), theta_vals)) plt.figure(figsize=(10, 6)) for A_vals, thetas in steady_states: plt.plot(A_vals, thetas, ',k', alpha=0.5) plt.title(\"Bifurcation Diagram (A vs \u03b8)\") plt.xlabel(\"Driving Amplitude A\") plt.ylabel(\"\u03b8 mod 2\u03c0\") plt.grid(True) plt.show() 7. Lyapunov Exponent Estimation Estimate the largest Lyapunov exponent to determine chaos. def estimate_lyapunov(delta0=1e-8, T_max=100): y1 = np.array([0.1, 0.0]) y2 = y1 + np.array([delta0, 0]) times = np.linspace(0, T_max, 10000) d_list = [] for t in range(len(times) - 1): sol1 = solve_ivp(pendulum, [times[t], times[t+1]], y1, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) sol2 = solve_ivp(pendulum, [times[t], times[t+1]], y2, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) y1 = sol1.y[:, -1] y2 = sol2.y[:, -1] delta = np.linalg.norm(y2 - y1) d_list.append(np.log(delta / delta0)) y2 = y1 + delta0 * (y2 - y1) / delta # Renormalize return times[1:], np.cumsum(d_list) / np.arange(1, len(d_list)+1) ltimes, lyap = estimate_lyapunov() plt.figure(figsize=(8, 4)) plt.plot(ltimes, lyap) plt.title(\"Estimated Largest Lyapunov Exponent\") plt.xlabel(\"Time\") plt.ylabel(\"Lyapunov Exponent\") plt.grid(True) plt.show() 8. Exploring Parameters Experimenting with parameters leads to different behaviors: - Increasing A may cause chaotic motion. - Lowering \u03b3 shows less damping, leading to longer sustained oscillations. - Matching \u03c9 with \u03c9\u2080 creates resonance, producing large amplitudes. \ud83d\udd04 Extended Visualization: Adding Forced but Undamped Pendulum This scenario demonstrates periodic motion with sustained energy input and no damping, resulting in regular oscillations without energy loss \u2014 a resonance-friendly setup. We now add the fourth scenario that was previously missing: Case Damping ( \\(b\\) ) Forcing ( \\(A\\) ) Simple Pendulum 0 0 Damped Pendulum 0.5 0 Forced Damped Pendulum 0.5 1.2 Forced (Undamped) Pendulum 0 1.2 \u2705 NEW This configuration shows how the system behaves when it's driven but has no energy loss \u2013 a potentially resonant and unstable regime. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] gamma_forced_undamped = 0.0 A_forced = 1.2 omega_drive = 2.0 sol_forced_undamped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(gamma_forced_undamped, A_forced, omega_drive)) plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol_forced_undamped.t, sol_forced_undamped.y[0]) plt.title(\"Forced (Undamped) Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(1, 2, 2) plt.plot(sol_forced_undamped.y[0], sol_forced_undamped.y[1]) plt.title(\"Forced (Undamped) Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show() 9. Real-World Applications Energy Harvesters : Pendulums can convert motion into usable energy. Bridge Engineering : Avoiding resonance in suspension bridges is crucial. Washing Machines : Proper damping reduces imbalance. Electronics : RLC circuits have similar equations. Clocks : Pendulum clocks are based on resonance principles. 10. Model Limitations and Extensions The model assumes ideal sine driving forces. Real-world damping is often nonlinear. It doesn't account for multi-dimensional motion. Possible Extensions Add random or non-periodic forcing. Add nonlinear damping (quadratic drag). Study bifurcation diagrams over varying A or \u03c9. Simulate coupled or double pendulums. FAQ - Common Questions 1. What makes the forced damped pendulum nonlinear? The presence of the \\(\\sin\\theta\\) term (instead of \\(\\theta\\) ) introduces nonlinearity, which makes the system exhibit complex dynamics such as chaos. 2. Why is damping important in the system? Damping removes energy from the system. Without it, the pendulum would keep oscillating forever if externally driven. 3. What happens at resonance? When the driving frequency matches the natural frequency ( \\(\\omega \\approx \\omega_0\\) ), the system absorbs maximum energy, causing large oscillations. 4. Why do we use the small-angle approximation? It simplifies the math by making the equation linear. It\u2019s only valid for small displacements (typically \\(\\theta < 10^{\\circ}\\) ). 5. What is a Poincar\u00e9 section and why is it useful? It\u2019s a snapshot of the system at regular intervals. It helps identify periodic vs chaotic behavior in a simpler 2D plot. 6. Can this system become chaotic? Yes. With certain combinations of damping, amplitude, and driving frequency, the system becomes highly sensitive to initial conditions and unpredictable. 7. What are real-world analogs of this system? Any system with damping and periodic forcing\u2014like RLC circuits, mechanical oscillators, or climate systems\u2014can be modeled similarly. Feel free to change the parameters and explore how simple rules can create unpredictable patterns. To fully illustrate the transition from simple to complex dynamics, we add simulations for: Simple Pendulum (no damping, no forcing) Damped Pendulum (with damping, no forcing) Forced Damped Pendulum (already shown above) We simulate and visualize angle-time plots and phase diagrams for the first two to complete the progression. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] sol_simple = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.0, 0.0, 0.0)) sol_damped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.5, 0.0, 0.0)) plt.figure(figsize=(14, 10)) plt.subplot(2, 2, 1) plt.plot(sol_simple.t, sol_simple.y[0]) plt.title(\"Simple Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 2) plt.plot(sol_simple.y[0], sol_simple.y[1]) plt.title(\"Simple Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.subplot(2, 2, 3) plt.plot(sol_damped.t, sol_damped.y[0]) plt.title(\"Damped Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 4) plt.plot(sol_damped.y[0], sol_damped.y[1]) plt.title(\"Damped Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show() Appendix: Completion Checklist Category Content Description Included? Theoretical Foundation Differential equation, small-angle approximation, and resonance explanation \u2705 Yes Python Simulation Time-domain simulation using solve_ivp and parameter configuration \u2705 Yes Phase Space Plot Visualization of the angular velocity vs angle (\u03b8 vs \u03c9) \u2705 Yes Poincar\u00e9 Section Stroboscopic mapping to visualize periodic vs chaotic behavior \u2705 Yes Energy Analysis Plot showing kinetic + potential energy over time \u2705 Yes Bifurcation Diagram Diagram showing system behavior vs driving amplitude (A) \u2705 Yes Lyapunov Exponent Numerical estimation of chaos via divergence of nearby trajectories \u2705 Yes Parameter Exploration Discussion of how \u03b3, A, and \u03c9 affect the dynamics \u2705 Yes Real-World Applications Analogies to bridges, electronics, and mechanical systems \u2705 Yes Model Limitations Discussion of assumptions and suggestions for extensions \u2705 Yes FAQ Section Seven clear and relevant conceptual questions with explanations \u2705 Yes","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a classic example of nonlinear dynamics. Unlike simple harmonic oscillators, this system responds to periodic external forces and damping, producing rich behavior that includes resonance, synchronization, and even chaos. This kind of system is fundamental in physics and engineering because it mirrors the behavior of real-world systems like suspension bridges, circuits, and mechanical vibration absorbers.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The general nonlinear equation for the forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement (radians) - \\(\\gamma\\) : damping coefficient (how quickly oscillations die out) - \\(\\omega_0\\) : natural angular frequency ( \\(\\omega_0 = \\sqrt{g / L}\\) for a pendulum of length \\(L\\) ) - \\(A\\) : amplitude of external force - \\(\\omega\\) : driving frequency","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"When \\(\\theta\\) is small (typically less than 10\u00b0), we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This form is a linear second-order ODE, easier to solve and useful for studying resonance behavior.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-python-simulation","text":"Let's simulate the pendulum using numerical methods. We'll use the Runge-Kutta method via scipy.integrate.solve_ivp . import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Differential equation def pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dydt = [omega_theta, -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Parameters gamma = 0.2 omega0 = 1.5 A = 1.2 omega_drive = 2.0 y0 = [0.1, 0.0] t_span = (0, 50) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) # Plot angle over time plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.grid(True) plt.legend() plt.show()","title":"2. Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-phase-space-vs","text":"This plot helps visualize how the system evolves in state space. plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Space') plt.xlabel('Angle \u03b8 (rad)') plt.ylabel('Angular Velocity \u03c9 (rad/s)') plt.grid(True) plt.show()","title":"3. Phase Space (\u03b8 vs \u03c9)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-poincare-section","text":"The Poincar\u00e9 section samples the system once per driving cycle, helping identify periodicity and chaos. T = 2 * np.pi / omega_drive poincare_times = np.arange(0, t_span[1], T) poincare_points = [] for t_p in poincare_times: idx = np.argmin(np.abs(sol.t - t_p)) poincare_points.append([sol.y[0][idx] % (2*np.pi), sol.y[1][idx]]) poincare_points = np.array(poincare_points) plt.figure(figsize=(6, 6)) plt.scatter(poincare_points[:, 0], poincare_points[:, 1], s=10, color='crimson') plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 mod $2\\pi$ (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.grid(True) plt.show()","title":"4. Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-additional-visualization-energy-over-time","text":"Visualizing total mechanical energy shows how damping and driving force interact. mass = 1.0 length = 1.0 g = 9.81 theta = sol.y[0] omega = sol.y[1] potential_energy = mass * g * length * (1 - np.cos(theta)) kinetic_energy = 0.5 * mass * (length**2) * omega**2 total_energy = potential_energy + kinetic_energy plt.figure(figsize=(10, 4)) plt.plot(sol.t, total_energy) plt.title('Total Mechanical Energy vs Time') plt.xlabel('Time (s)') plt.ylabel('Energy (J)') plt.grid(True) plt.show()","title":"5. Additional Visualization: Energy Over Time"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-bifurcation-diagram","text":"Explore how the long-term behavior changes with the driving amplitude A. bifurcation_A = np.linspace(1.0, 1.5, 300) steady_states = [] for A_val in bifurcation_A: sol = solve_ivp(pendulum, [0, 200], [0.1, 0.0], t_eval=np.linspace(150, 200, 500), args=(gamma, omega0, A_val, omega_drive)) theta_vals = sol.y[0] % (2 * np.pi) steady_states.append((np.full_like(theta_vals, A_val), theta_vals)) plt.figure(figsize=(10, 6)) for A_vals, thetas in steady_states: plt.plot(A_vals, thetas, ',k', alpha=0.5) plt.title(\"Bifurcation Diagram (A vs \u03b8)\") plt.xlabel(\"Driving Amplitude A\") plt.ylabel(\"\u03b8 mod 2\u03c0\") plt.grid(True) plt.show()","title":"6. Bifurcation Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#7-lyapunov-exponent-estimation","text":"Estimate the largest Lyapunov exponent to determine chaos. def estimate_lyapunov(delta0=1e-8, T_max=100): y1 = np.array([0.1, 0.0]) y2 = y1 + np.array([delta0, 0]) times = np.linspace(0, T_max, 10000) d_list = [] for t in range(len(times) - 1): sol1 = solve_ivp(pendulum, [times[t], times[t+1]], y1, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) sol2 = solve_ivp(pendulum, [times[t], times[t+1]], y2, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) y1 = sol1.y[:, -1] y2 = sol2.y[:, -1] delta = np.linalg.norm(y2 - y1) d_list.append(np.log(delta / delta0)) y2 = y1 + delta0 * (y2 - y1) / delta # Renormalize return times[1:], np.cumsum(d_list) / np.arange(1, len(d_list)+1) ltimes, lyap = estimate_lyapunov() plt.figure(figsize=(8, 4)) plt.plot(ltimes, lyap) plt.title(\"Estimated Largest Lyapunov Exponent\") plt.xlabel(\"Time\") plt.ylabel(\"Lyapunov Exponent\") plt.grid(True) plt.show()","title":"7. Lyapunov Exponent Estimation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#8-exploring-parameters","text":"Experimenting with parameters leads to different behaviors: - Increasing A may cause chaotic motion. - Lowering \u03b3 shows less damping, leading to longer sustained oscillations. - Matching \u03c9 with \u03c9\u2080 creates resonance, producing large amplitudes.","title":"8. Exploring Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extended-visualization-adding-forced-but-undamped-pendulum","text":"This scenario demonstrates periodic motion with sustained energy input and no damping, resulting in regular oscillations without energy loss \u2014 a resonance-friendly setup. We now add the fourth scenario that was previously missing: Case Damping ( \\(b\\) ) Forcing ( \\(A\\) ) Simple Pendulum 0 0 Damped Pendulum 0.5 0 Forced Damped Pendulum 0.5 1.2 Forced (Undamped) Pendulum 0 1.2 \u2705 NEW This configuration shows how the system behaves when it's driven but has no energy loss \u2013 a potentially resonant and unstable regime. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] gamma_forced_undamped = 0.0 A_forced = 1.2 omega_drive = 2.0 sol_forced_undamped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(gamma_forced_undamped, A_forced, omega_drive)) plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol_forced_undamped.t, sol_forced_undamped.y[0]) plt.title(\"Forced (Undamped) Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(1, 2, 2) plt.plot(sol_forced_undamped.y[0], sol_forced_undamped.y[1]) plt.title(\"Forced (Undamped) Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udd04 Extended Visualization: Adding Forced but Undamped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#9-real-world-applications","text":"Energy Harvesters : Pendulums can convert motion into usable energy. Bridge Engineering : Avoiding resonance in suspension bridges is crucial. Washing Machines : Proper damping reduces imbalance. Electronics : RLC circuits have similar equations. Clocks : Pendulum clocks are based on resonance principles.","title":"9. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#10-model-limitations-and-extensions","text":"The model assumes ideal sine driving forces. Real-world damping is often nonlinear. It doesn't account for multi-dimensional motion.","title":"10. Model Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#possible-extensions","text":"Add random or non-periodic forcing. Add nonlinear damping (quadratic drag). Study bifurcation diagrams over varying A or \u03c9. Simulate coupled or double pendulums.","title":"Possible Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#faq-common-questions","text":"1. What makes the forced damped pendulum nonlinear? The presence of the \\(\\sin\\theta\\) term (instead of \\(\\theta\\) ) introduces nonlinearity, which makes the system exhibit complex dynamics such as chaos. 2. Why is damping important in the system? Damping removes energy from the system. Without it, the pendulum would keep oscillating forever if externally driven. 3. What happens at resonance? When the driving frequency matches the natural frequency ( \\(\\omega \\approx \\omega_0\\) ), the system absorbs maximum energy, causing large oscillations. 4. Why do we use the small-angle approximation? It simplifies the math by making the equation linear. It\u2019s only valid for small displacements (typically \\(\\theta < 10^{\\circ}\\) ). 5. What is a Poincar\u00e9 section and why is it useful? It\u2019s a snapshot of the system at regular intervals. It helps identify periodic vs chaotic behavior in a simpler 2D plot. 6. Can this system become chaotic? Yes. With certain combinations of damping, amplitude, and driving frequency, the system becomes highly sensitive to initial conditions and unpredictable. 7. What are real-world analogs of this system? Any system with damping and periodic forcing\u2014like RLC circuits, mechanical oscillators, or climate systems\u2014can be modeled similarly. Feel free to change the parameters and explore how simple rules can create unpredictable patterns. To fully illustrate the transition from simple to complex dynamics, we add simulations for: Simple Pendulum (no damping, no forcing) Damped Pendulum (with damping, no forcing) Forced Damped Pendulum (already shown above) We simulate and visualize angle-time plots and phase diagrams for the first two to complete the progression. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] sol_simple = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.0, 0.0, 0.0)) sol_damped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.5, 0.0, 0.0)) plt.figure(figsize=(14, 10)) plt.subplot(2, 2, 1) plt.plot(sol_simple.t, sol_simple.y[0]) plt.title(\"Simple Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 2) plt.plot(sol_simple.y[0], sol_simple.y[1]) plt.title(\"Simple Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.subplot(2, 2, 3) plt.plot(sol_damped.t, sol_damped.y[0]) plt.title(\"Damped Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 4) plt.plot(sol_damped.y[0], sol_damped.y[1]) plt.title(\"Damped Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show()","title":"FAQ - Common Questions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#appendix-completion-checklist","text":"Category Content Description Included? Theoretical Foundation Differential equation, small-angle approximation, and resonance explanation \u2705 Yes Python Simulation Time-domain simulation using solve_ivp and parameter configuration \u2705 Yes Phase Space Plot Visualization of the angular velocity vs angle (\u03b8 vs \u03c9) \u2705 Yes Poincar\u00e9 Section Stroboscopic mapping to visualize periodic vs chaotic behavior \u2705 Yes Energy Analysis Plot showing kinetic + potential energy over time \u2705 Yes Bifurcation Diagram Diagram showing system behavior vs driving amplitude (A) \u2705 Yes Lyapunov Exponent Numerical estimation of chaos via divergence of nearby trajectories \u2705 Yes Parameter Exploration Discussion of how \u03b3, A, and \u03c9 affect the dynamics \u2705 Yes Real-World Applications Analogies to bridges, electronics, and mechanical systems \u2705 Yes Model Limitations Discussion of assumptions and suggestions for extensions \u2705 Yes FAQ Section Seven clear and relevant conceptual questions with explanations \u2705 Yes","title":"Appendix: Completion Checklist"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation Kepler's Third Law elegantly describes how the time a celestial object takes to complete its orbit depends on the size of the orbit itself. This deep relationship between period and radius provides powerful tools for calculating planetary distances, masses of stars, and understanding orbital mechanics in systems ranging from satellites to exoplanets. Derivation of Kepler's Third Law for Circular Orbits For an object of mass \\(m\\) orbiting a massive body of mass \\(M\\) : The gravitational force provides the necessary centripetal force: \\[ \\frac{GMm}{r^2} = m \\frac{v^2}{r} \\] Simplifying for orbital velocity \\(v\\) : \\[ v = \\sqrt{\\frac{GM}{r}} \\] The orbital period \\(T\\) relates to the circumference of the orbit and velocity: \\[ T = \\frac{2\\pi r}{v} = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{GM} r^3 \\] Thus: \\[ T^2 \\propto r^3 \\] Applications in Astronomy Measuring Masses : Orbital data reveal masses of stars, planets, and galaxies. Mapping Distances : Knowing the period allows inferring distances without direct measurement. Predicting Motion : Useful for satellite placement and mission planning. Real-World Examples 1. Moon's Orbit Around Earth import numpy as np import matplotlib.pyplot as plt # Constants g = 6.67430e-11 # m^3 kg^-1 s^-2 M_earth = 5.972e24 # kg r_moon = 384400e3 # meters # Orbital period calculation T_moon = 2 * np.pi * np.sqrt(r_moon**3 / (g * M_earth)) T_moon_days = T_moon / (60 * 60 * 24) print(f\"Calculated Orbital Period of Moon: {T_moon_days:.2f} days\") Calculated Orbital Period of Moon: 27.45 days Note: This code calculates the Moon's orbital period around Earth using gravitational principles. Visualizing Moon's Orbit # Simulate the orbit n_frames = 250 theta = np.linspace(0, 2*np.pi, n_frames) x_moon = r_moon * np.cos(theta) y_moon = r_moon * np.sin(theta) fig, ax = plt.subplots(figsize=(6,6)) ax.plot(0, 0, 'yo', label='Earth', markersize=12) ax.plot(x_moon, y_moon, 'b--', alpha=0.7) ax.set_aspect('equal') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Moon Orbiting Earth') plt.legend() plt.grid() plt.show() Note: This simulation shows the Moon's near-circular orbit around Earth. 2. Inner Planets in the Solar System # Inner Planets data radii_AU = np.array([0.39, 0.72, 1.00, 1.52]) # AU periods_years = np.array([0.24, 0.62, 1.00, 1.88]) planets = ['Mercury', 'Venus', 'Earth', 'Mars'] r_cubed = radii_AU**3 T_squared = periods_years**2 # Plot plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o-', color='royalblue', label=r'$T^2$ vs $r^3$') for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(5,5), ha='center') plt.xlabel('Orbital Radius$^3$ (AU$^3$)', fontsize=12) plt.ylabel('Orbital Period$^2$ (Years$^2$)', fontsize=12) plt.title(r\"Kepler's Third Law: $T^2 \\propto r^3$\", fontsize=14) plt.legend() plt.grid(True) plt.tight_layout() plt.show() Note: This plot confirms the \\(T^2 \\propto r^3\\) relationship for the inner planets. 3. ISS Orbit Around Earth # Constants for ISS r_iss = 6771e3 # Radius from Earth's center to ISS (Earth's radius + 400 km altitude) # Orbital period calculation for ISS T_iss = 2 * np.pi * np.sqrt(r_iss**3 / (g * M_earth)) T_iss_minutes = T_iss / 60 print(f\"Orbital Period of ISS: {T_iss_minutes:.2f} minutes\") Orbital Period of ISS: 92.42 minutes Note: This example shows that the ISS completes an orbit in about 90 minutes, much faster than the Moon. Log-Log Plot of \\(T^2\\) vs \\(r^3\\) # Log-log plot plt.figure(figsize=(8,6)) plt.loglog(r_cubed, T_squared, 'o-', color='purple') plt.xlabel('log($r^3$) (AU$^3$)') plt.ylabel('log($T^2$) (Years$^2$)') plt.title('Log-Log Plot: Kepler\\'s Third Law') plt.grid(True, which='both', ls='--') plt.tight_layout() plt.show() Note: A straight line in the log-log plot verifies the power-law relationship. Extension to Elliptical Orbits Kepler generalized his Third Law for ellipses by replacing \\(r\\) with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2}{GM} a^3 \\] Thus, whether an orbit is circular or elliptical, the relation remains consistent. Simulation: Fitting \\(T^2\\) vs \\(r^3\\) # Fit and plot linear regression from scipy.stats import linregress slope, intercept, r_value, _, _ = linregress(r_cubed, T_squared) fit_line = slope * r_cubed + intercept plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o', label='Observed') plt.plot(r_cubed, fit_line, '-', label=f\"Fit: $T^2 = {slope:.2f}r^3 + {intercept:.2f}$\") plt.xlabel('$r^3$ (AU$^3$)') plt.ylabel('$T^2$ (Years$^2$)') plt.title(\"Linear Fit of Kepler's Law\") plt.legend() plt.grid() plt.tight_layout() plt.show() Note: The best-fit line shows how closely the data follows Kepler's Third Law. Conclusion Kepler's Third Law, emerging from simple physical principles, connects space and time in the cosmos. From moons to exoplanets, understanding \\(T^2 \\propto r^3\\) remains a foundational tool in modern astronomy and physics. Frequently Asked Questions (FAQ) Q1: Why does \\(T^2\\) scale with \\(r^3\\) ? Because gravitational force decreases with distance squared, and orbital speed depends on this force. When combined with the relationship between velocity and period, it leads to \\(T^2 \\propto r^3\\) . Q2: Does Kepler's Third Law apply to non-circular orbits? Yes, it applies to elliptical orbits if we replace \\(r\\) with the semi-major axis \\(a\\) . Q3: Why do satellites like ISS orbit faster than the Moon? The closer an object is to Earth, the stronger the gravitational force, leading to a higher orbital velocity and shorter period. Q4: What happens if another force acts during orbit? Additional forces (like atmospheric drag) can cause deviations from pure Keplerian motion, requiring corrections. Q5: How is Kepler's Law used today? It is critical for satellite deployment, interplanetary travel planning, and discovery of exoplanets by observing transit periods and orbital dynamics. Visit Colab","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law elegantly describes how the time a celestial object takes to complete its orbit depends on the size of the orbit itself. This deep relationship between period and radius provides powerful tools for calculating planetary distances, masses of stars, and understanding orbital mechanics in systems ranging from satellites to exoplanets.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"For an object of mass \\(m\\) orbiting a massive body of mass \\(M\\) : The gravitational force provides the necessary centripetal force: \\[ \\frac{GMm}{r^2} = m \\frac{v^2}{r} \\] Simplifying for orbital velocity \\(v\\) : \\[ v = \\sqrt{\\frac{GM}{r}} \\] The orbital period \\(T\\) relates to the circumference of the orbit and velocity: \\[ T = \\frac{2\\pi r}{v} = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{GM} r^3 \\] Thus: \\[ T^2 \\propto r^3 \\]","title":"Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#applications-in-astronomy","text":"Measuring Masses : Orbital data reveal masses of stars, planets, and galaxies. Mapping Distances : Knowing the period allows inferring distances without direct measurement. Predicting Motion : Useful for satellite placement and mission planning.","title":"Applications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-moons-orbit-around-earth","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 6.67430e-11 # m^3 kg^-1 s^-2 M_earth = 5.972e24 # kg r_moon = 384400e3 # meters # Orbital period calculation T_moon = 2 * np.pi * np.sqrt(r_moon**3 / (g * M_earth)) T_moon_days = T_moon / (60 * 60 * 24) print(f\"Calculated Orbital Period of Moon: {T_moon_days:.2f} days\") Calculated Orbital Period of Moon: 27.45 days Note: This code calculates the Moon's orbital period around Earth using gravitational principles.","title":"1. Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visualizing-moons-orbit","text":"# Simulate the orbit n_frames = 250 theta = np.linspace(0, 2*np.pi, n_frames) x_moon = r_moon * np.cos(theta) y_moon = r_moon * np.sin(theta) fig, ax = plt.subplots(figsize=(6,6)) ax.plot(0, 0, 'yo', label='Earth', markersize=12) ax.plot(x_moon, y_moon, 'b--', alpha=0.7) ax.set_aspect('equal') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Moon Orbiting Earth') plt.legend() plt.grid() plt.show() Note: This simulation shows the Moon's near-circular orbit around Earth.","title":"Visualizing Moon's Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-inner-planets-in-the-solar-system","text":"# Inner Planets data radii_AU = np.array([0.39, 0.72, 1.00, 1.52]) # AU periods_years = np.array([0.24, 0.62, 1.00, 1.88]) planets = ['Mercury', 'Venus', 'Earth', 'Mars'] r_cubed = radii_AU**3 T_squared = periods_years**2 # Plot plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o-', color='royalblue', label=r'$T^2$ vs $r^3$') for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(5,5), ha='center') plt.xlabel('Orbital Radius$^3$ (AU$^3$)', fontsize=12) plt.ylabel('Orbital Period$^2$ (Years$^2$)', fontsize=12) plt.title(r\"Kepler's Third Law: $T^2 \\propto r^3$\", fontsize=14) plt.legend() plt.grid(True) plt.tight_layout() plt.show() Note: This plot confirms the \\(T^2 \\propto r^3\\) relationship for the inner planets.","title":"2. Inner Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-iss-orbit-around-earth","text":"# Constants for ISS r_iss = 6771e3 # Radius from Earth's center to ISS (Earth's radius + 400 km altitude) # Orbital period calculation for ISS T_iss = 2 * np.pi * np.sqrt(r_iss**3 / (g * M_earth)) T_iss_minutes = T_iss / 60 print(f\"Orbital Period of ISS: {T_iss_minutes:.2f} minutes\") Orbital Period of ISS: 92.42 minutes Note: This example shows that the ISS completes an orbit in about 90 minutes, much faster than the Moon.","title":"3. ISS Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#log-log-plot-of-t2-vs-r3","text":"# Log-log plot plt.figure(figsize=(8,6)) plt.loglog(r_cubed, T_squared, 'o-', color='purple') plt.xlabel('log($r^3$) (AU$^3$)') plt.ylabel('log($T^2$) (Years$^2$)') plt.title('Log-Log Plot: Kepler\\'s Third Law') plt.grid(True, which='both', ls='--') plt.tight_layout() plt.show() Note: A straight line in the log-log plot verifies the power-law relationship.","title":"Log-Log Plot of \\(T^2\\) vs \\(r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler generalized his Third Law for ellipses by replacing \\(r\\) with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2}{GM} a^3 \\] Thus, whether an orbit is circular or elliptical, the relation remains consistent.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#simulation-fitting-t2-vs-r3","text":"# Fit and plot linear regression from scipy.stats import linregress slope, intercept, r_value, _, _ = linregress(r_cubed, T_squared) fit_line = slope * r_cubed + intercept plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o', label='Observed') plt.plot(r_cubed, fit_line, '-', label=f\"Fit: $T^2 = {slope:.2f}r^3 + {intercept:.2f}$\") plt.xlabel('$r^3$ (AU$^3$)') plt.ylabel('$T^2$ (Years$^2$)') plt.title(\"Linear Fit of Kepler's Law\") plt.legend() plt.grid() plt.tight_layout() plt.show() Note: The best-fit line shows how closely the data follows Kepler's Third Law.","title":"Simulation: Fitting \\(T^2\\) vs \\(r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law, emerging from simple physical principles, connects space and time in the cosmos. From moons to exoplanets, understanding \\(T^2 \\propto r^3\\) remains a foundational tool in modern astronomy and physics.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q1-why-does-t2-scale-with-r3","text":"Because gravitational force decreases with distance squared, and orbital speed depends on this force. When combined with the relationship between velocity and period, it leads to \\(T^2 \\propto r^3\\) .","title":"Q1: Why does \\(T^2\\) scale with \\(r^3\\)?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q2-does-keplers-third-law-apply-to-non-circular-orbits","text":"Yes, it applies to elliptical orbits if we replace \\(r\\) with the semi-major axis \\(a\\) .","title":"Q2: Does Kepler's Third Law apply to non-circular orbits?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q3-why-do-satellites-like-iss-orbit-faster-than-the-moon","text":"The closer an object is to Earth, the stronger the gravitational force, leading to a higher orbital velocity and shorter period.","title":"Q3: Why do satellites like ISS orbit faster than the Moon?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q4-what-happens-if-another-force-acts-during-orbit","text":"Additional forces (like atmospheric drag) can cause deviations from pure Keplerian motion, requiring corrections.","title":"Q4: What happens if another force acts during orbit?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q5-how-is-keplers-law-used-today","text":"It is critical for satellite deployment, interplanetary travel planning, and discovery of exoplanets by observing transit periods and orbital dynamics. Visit Colab","title":"Q5: How is Kepler's Law used today?"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is fundamental to understanding how an object can overcome the gravitational pull of a celestial body. Extending this idea, the definitions of the first , second , and third cosmic velocities describe thresholds for orbiting a planet, escaping a planet's gravity, and leaving a star system entirely. These principles are crucial for designing satellite launches, planning interplanetary missions, and imagining future interstellar travel. Definitions of Cosmic Velocities First Cosmic Velocity ( \\(v_1\\) ): The minimum velocity needed for a stable circular orbit around a planet without propulsion. Second Cosmic Velocity ( \\(v_2\\) ): The escape velocity \u2014 the minimum velocity needed to break free from a celestial body's gravitational field. Third Cosmic Velocity ( \\(v_3\\) ): The minimum velocity needed to escape the gravitational influence of the star (e.g., the Sun) after escaping the planet. Mathematical Derivations 1. First Cosmic Velocity ( \\(v_1\\) ) Derived by equating the gravitational force to the centripetal force needed for circular motion: \\[ \\frac{GMm}{r^2} = m \\frac{v_1^2}{r} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] 2. Second Cosmic Velocity ( \\(v_2\\) ) Derived from energy conservation: kinetic energy must match gravitational potential energy. \\[ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} \\] Thus: \\[ v_2 = \\sqrt{2} v_1 \\] or \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] 3. Third Cosmic Velocity ( \\(v_3\\) ) Requires overcoming the planet's gravity and then escaping the Sun's gravity from Earth's orbit. For approximate calculation: \\[ v_3 \\approx \\sqrt{v_2^2 + v_{esc, Sun}^2} \\] where \\(v_{esc, Sun}\\) is the Sun's escape velocity at the planet's orbital distance. Python Simulation and Visualization We will compute \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) for Earth , Mars , and Jupiter . import numpy as np import matplotlib.pyplot as plt import pandas as pd # Constants G = 6.67430e-11 # Gravitational constant, m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun, kg # Celestial bodies data bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6371e3, 'orbital_radius': 1.496e11}, 'Mars': {'mass': 6.417e23, 'radius': 3389.5e3, 'orbital_radius': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 69911e3, 'orbital_radius': 7.785e11} } # Function to calculate velocities def calculate_cosmic_velocities(mass, radius, orbital_radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 v_esc_sun = np.sqrt(2 * G * M_sun / orbital_radius) v3 = np.sqrt(v2**2 + v_esc_sun**2) return v1, v2, v3 # Store results results = {} for body, data in bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data['mass'], data['radius'], data['orbital_radius']) results[body] = {'mass': data['mass'], 'v1': v1, 'v2': v2, 'v3': v3} # Display results for body, velocities in results.items(): print(f\"{body}: v1 = {velocities['v1']:.2f} m/s, v2 = {velocities['v2']:.2f} m/s, v3 = {velocities['v3']:.2f} m/s\") Earth: v1 = 7909.68 m/s, v2 = 11185.98 m/s, v3 = 43587.65 m/s Mars: v1 = 3554.68 m/s, v2 = 5027.08 m/s, v3 = 34500.32 m/s Jupiter: v1 = 42567.51 m/s, v2 = 60199.54 m/s, v3 = 62968.49 m/s Note: This script calculates the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Graphical Representations 1. Bar Chart of Cosmic Velocities labels = list(results.keys()) v1_vals = [results[body]['v1'] for body in labels] v2_vals = [results[body]['v2'] for body in labels] v3_vals = [results[body]['v3'] for body in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (m/s)') ax.set_title('Comparison of Cosmic Velocities') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() 2. Line Plot of Cosmic Velocities plt.figure(figsize=(10,6)) plt.plot(labels, v1_vals, 'o-', label='First Cosmic Velocity') plt.plot(labels, v2_vals, 's-', label='Second Cosmic Velocity') plt.plot(labels, v3_vals, 'd-', label='Third Cosmic Velocity') plt.xlabel('Celestial Body') plt.ylabel('Velocity (m/s)') plt.title('Trends of Cosmic Velocities') plt.legend() plt.grid(True) plt.tight_layout() plt.show() 3. Tabular Summary of Velocities df = pd.DataFrame(results).T[['v1', 'v2', 'v3']] print(df) 4. Log-Log Plot (Mass vs Escape Velocity) mass_vals = [results[body]['mass'] for body in labels] v2_vals = [results[body]['v2'] for body in labels] plt.figure(figsize=(8,6)) plt.loglog(mass_vals, v2_vals, 'o-', markersize=8) plt.xlabel('Mass (kg)') plt.ylabel('Second Cosmic Velocity (m/s)') plt.title('Log-Log Plot: Mass vs Escape Velocity') plt.grid(True, which='both', ls='--') plt.tight_layout() plt.show() 5. Pie Chart (Relative Escape Velocities) plt.figure(figsize=(8,8)) plt.pie(v2_vals, labels=labels, autopct='%1.1f%%', startangle=140) plt.title('Relative Escape Velocities of Planets') plt.tight_layout() plt.show() Importance in Space Exploration First Cosmic Velocity: Required to place satellites into stable orbit. Second Cosmic Velocity: Needed for missions leaving a planet, such as Moon and Mars exploration. Third Cosmic Velocity: Necessary for deep-space missions and interstellar exploration planning. Understanding these velocities informs spacecraft design, mission trajectories, and fuel requirements. Conclusion Escape velocities and cosmic velocities set the fundamental energy thresholds that govern space exploration. Mastery of these concepts has enabled humanity to place satellites in orbit, reach other planets, and imagine future journeys beyond the Solar System. Frequently Asked Questions (FAQ) Q1: Why is the second cosmic velocity higher than the first? Because escaping a planet's gravity requires more energy than simply maintaining a stable orbit. Q2: Why does Jupiter have a much higher escape velocity than Earth? Due to its significantly greater mass and size, creating a stronger gravitational field. Q3: What challenges exist in achieving the third cosmic velocity? The enormous amount of energy and precise navigation needed to escape a star's gravity well. Q4: How are these velocities achieved in practice? Using multi-stage rockets, gravitational assists, and carefully planned launch trajectories. Q5: Are cosmic velocities affected by atmospheres? Yes, atmospheric drag must be overcome, requiring additional velocity beyond the theoretical minimums when launching from planets with atmospheres like Earth. Visit Colab","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is fundamental to understanding how an object can overcome the gravitational pull of a celestial body. Extending this idea, the definitions of the first , second , and third cosmic velocities describe thresholds for orbiting a planet, escaping a planet's gravity, and leaving a star system entirely. These principles are crucial for designing satellite launches, planning interplanetary missions, and imagining future interstellar travel.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"First Cosmic Velocity ( \\(v_1\\) ): The minimum velocity needed for a stable circular orbit around a planet without propulsion. Second Cosmic Velocity ( \\(v_2\\) ): The escape velocity \u2014 the minimum velocity needed to break free from a celestial body's gravitational field. Third Cosmic Velocity ( \\(v_3\\) ): The minimum velocity needed to escape the gravitational influence of the star (e.g., the Sun) after escaping the planet.","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v_1","text":"Derived by equating the gravitational force to the centripetal force needed for circular motion: \\[ \\frac{GMm}{r^2} = m \\frac{v_1^2}{r} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\]","title":"1. First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-v_2","text":"Derived from energy conservation: kinetic energy must match gravitational potential energy. \\[ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} \\] Thus: \\[ v_2 = \\sqrt{2} v_1 \\] or \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\]","title":"2. Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v_3","text":"Requires overcoming the planet's gravity and then escaping the Sun's gravity from Earth's orbit. For approximate calculation: \\[ v_3 \\approx \\sqrt{v_2^2 + v_{esc, Sun}^2} \\] where \\(v_{esc, Sun}\\) is the Sun's escape velocity at the planet's orbital distance.","title":"3. Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation-and-visualization","text":"We will compute \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) for Earth , Mars , and Jupiter . import numpy as np import matplotlib.pyplot as plt import pandas as pd # Constants G = 6.67430e-11 # Gravitational constant, m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun, kg # Celestial bodies data bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6371e3, 'orbital_radius': 1.496e11}, 'Mars': {'mass': 6.417e23, 'radius': 3389.5e3, 'orbital_radius': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 69911e3, 'orbital_radius': 7.785e11} } # Function to calculate velocities def calculate_cosmic_velocities(mass, radius, orbital_radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 v_esc_sun = np.sqrt(2 * G * M_sun / orbital_radius) v3 = np.sqrt(v2**2 + v_esc_sun**2) return v1, v2, v3 # Store results results = {} for body, data in bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data['mass'], data['radius'], data['orbital_radius']) results[body] = {'mass': data['mass'], 'v1': v1, 'v2': v2, 'v3': v3} # Display results for body, velocities in results.items(): print(f\"{body}: v1 = {velocities['v1']:.2f} m/s, v2 = {velocities['v2']:.2f} m/s, v3 = {velocities['v3']:.2f} m/s\") Earth: v1 = 7909.68 m/s, v2 = 11185.98 m/s, v3 = 43587.65 m/s Mars: v1 = 3554.68 m/s, v2 = 5027.08 m/s, v3 = 34500.32 m/s Jupiter: v1 = 42567.51 m/s, v2 = 60199.54 m/s, v3 = 62968.49 m/s Note: This script calculates the first, second, and third cosmic velocities for Earth, Mars, and Jupiter.","title":"Python Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#graphical-representations","text":"","title":"Graphical Representations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-bar-chart-of-cosmic-velocities","text":"labels = list(results.keys()) v1_vals = [results[body]['v1'] for body in labels] v2_vals = [results[body]['v2'] for body in labels] v3_vals = [results[body]['v3'] for body in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (m/s)') ax.set_title('Comparison of Cosmic Velocities') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show()","title":"1. Bar Chart of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-line-plot-of-cosmic-velocities","text":"plt.figure(figsize=(10,6)) plt.plot(labels, v1_vals, 'o-', label='First Cosmic Velocity') plt.plot(labels, v2_vals, 's-', label='Second Cosmic Velocity') plt.plot(labels, v3_vals, 'd-', label='Third Cosmic Velocity') plt.xlabel('Celestial Body') plt.ylabel('Velocity (m/s)') plt.title('Trends of Cosmic Velocities') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"2. Line Plot of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-tabular-summary-of-velocities","text":"df = pd.DataFrame(results).T[['v1', 'v2', 'v3']] print(df)","title":"3. Tabular Summary of Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-log-log-plot-mass-vs-escape-velocity","text":"mass_vals = [results[body]['mass'] for body in labels] v2_vals = [results[body]['v2'] for body in labels] plt.figure(figsize=(8,6)) plt.loglog(mass_vals, v2_vals, 'o-', markersize=8) plt.xlabel('Mass (kg)') plt.ylabel('Second Cosmic Velocity (m/s)') plt.title('Log-Log Plot: Mass vs Escape Velocity') plt.grid(True, which='both', ls='--') plt.tight_layout() plt.show()","title":"4. Log-Log Plot (Mass vs Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-pie-chart-relative-escape-velocities","text":"plt.figure(figsize=(8,8)) plt.pie(v2_vals, labels=labels, autopct='%1.1f%%', startangle=140) plt.title('Relative Escape Velocities of Planets') plt.tight_layout() plt.show()","title":"5. Pie Chart (Relative Escape Velocities)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity: Required to place satellites into stable orbit. Second Cosmic Velocity: Needed for missions leaving a planet, such as Moon and Mars exploration. Third Cosmic Velocity: Necessary for deep-space missions and interstellar exploration planning. Understanding these velocities informs spacecraft design, mission trajectories, and fuel requirements.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Escape velocities and cosmic velocities set the fundamental energy thresholds that govern space exploration. Mastery of these concepts has enabled humanity to place satellites in orbit, reach other planets, and imagine future journeys beyond the Solar System.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q1-why-is-the-second-cosmic-velocity-higher-than-the-first","text":"Because escaping a planet's gravity requires more energy than simply maintaining a stable orbit.","title":"Q1: Why is the second cosmic velocity higher than the first?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q2-why-does-jupiter-have-a-much-higher-escape-velocity-than-earth","text":"Due to its significantly greater mass and size, creating a stronger gravitational field.","title":"Q2: Why does Jupiter have a much higher escape velocity than Earth?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q3-what-challenges-exist-in-achieving-the-third-cosmic-velocity","text":"The enormous amount of energy and precise navigation needed to escape a star's gravity well.","title":"Q3: What challenges exist in achieving the third cosmic velocity?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q4-how-are-these-velocities-achieved-in-practice","text":"Using multi-stage rockets, gravitational assists, and carefully planned launch trajectories.","title":"Q4: How are these velocities achieved in practice?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q5-are-cosmic-velocities-affected-by-atmospheres","text":"Yes, atmospheric drag must be overcome, requiring additional velocity beyond the theoretical minimums when launching from planets with atmospheres like Earth. Visit Colab","title":"Q5: Are cosmic velocities affected by atmospheres?"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions such as velocity, angle, and altitude. This problem blends principles of orbital mechanics, energy conservation, and numerical simulation. Understanding these trajectories is critical for missions like satellite deployment, reentry modules, or escaping Earth's gravity. Types of Possible Trajectories Depending on the initial velocity ( \\(v_0\\) ) and altitude ( \\(h\\) ), a payload can follow different paths: Elliptical Orbit : \\(v_0\\) < escape velocity; payload remains bound to Earth. Parabolic Trajectory : \\(v_0\\) \u2248 escape velocity; payload barely escapes Earth's gravity. Hyperbolic Trajectory : \\(v_0\\) > escape velocity; payload escapes with excess kinetic energy. Suborbital Trajectory : \\(v_0\\) too low for orbit; payload falls back to Earth. Fundamental Equations Gravitational Force: \\(F = \\frac{GMm}{r^2}\\) Gravitational Potential Energy: \\(U = -\\frac{GMm}{r}\\) Kinetic Energy: \\(K = \\frac{1}{2}mv^2\\) Total Energy (E): \\(E = K + U\\) If \\(E < 0\\) : Elliptical orbit If \\(E = 0\\) : Parabolic trajectory If \\(E > 0\\) : Hyperbolic escape Constants and Initial Setup import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6371e3 # Radius of Earth (m) altitude = 300e3 # Payload release altitude (m) r0 = R_earth + altitude v_escape = np.sqrt(2 * G * M_earth / r0) print(f\"Escape velocity at {altitude/1000:.0f} km altitude: {v_escape/1000:.2f} km/s\") Escape velocity at 300 km altitude: 10.93 km/s Note: The escape velocity at the release altitude is printed for reference. Trajectories of Payloads initial_velocities = [0.7 * v_escape, v_escape, 1.2 * v_escape] labels = ['Elliptical Orbit', 'Parabolic Escape', 'Hyperbolic Escape'] dt = 1 # Time step (s) steps = 15000 fig, ax_traj = plt.subplots(figsize=(8,8)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) x_vals, y_vals = [], [] for _ in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt x_vals.append(pos[0]) y_vals.append(pos[1]) if r < R_earth: break ax_traj.plot(x_vals, y_vals, label=label) # Draw Earth theta = np.linspace(0, 2*np.pi, 100) ax_traj.plot(R_earth*np.cos(theta), R_earth*np.sin(theta), 'k') ax_traj.set_aspect('equal') ax_traj.set_xlim(-2e7, 2e7) ax_traj.set_ylim(-2e7, 2e7) ax_traj.set_xlabel('x (m)') ax_traj.set_ylabel('y (m)') ax_traj.set_title('Payload Trajectories') ax_traj.legend() ax_traj.grid() plt.show() Note: This plot shows how different initial speeds result in different types of trajectories. Energy vs Time fig, ax_energy = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) E_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt energy = 0.5 * np.linalg.norm(vel)**2 - G * M_earth / r E_vals.append(energy) t_vals.append(t * dt) if r < R_earth: break ax_energy.plot(t_vals, E_vals, label=label) ax_energy.set_xlabel('Time (s)') ax_energy.set_ylabel('Specific Energy (J/kg)') ax_energy.set_title('Energy vs Time') ax_energy.legend() ax_energy.grid() plt.show() Note: This plot shows how the total specific energy evolves over time for different cases. Velocity vs Time fig, ax_velocity = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) v_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt v_vals.append(np.linalg.norm(vel)) t_vals.append(t * dt) if r < R_earth: break ax_velocity.plot(t_vals, v_vals, label=label) ax_velocity.set_xlabel('Time (s)') ax_velocity.set_ylabel('Velocity (m/s)') ax_velocity.set_title('Velocity vs Time') ax_velocity.legend() ax_velocity.grid() plt.show() Note: This plot shows how the payload speed changes with time depending on initial conditions. Distance from Earth vs Time fig, ax_distance = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) r_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt r_vals.append(r) t_vals.append(t * dt) if r < R_earth: break ax_distance.plot(t_vals, r_vals, label=label) ax_distance.set_xlabel('Time (s)') ax_distance.set_ylabel('Distance from Earth Center (m)') ax_distance.set_title('Distance vs Time') ax_distance.legend() ax_distance.grid() plt.show() Note: This plot shows the distance of the payload from the Earth's center as a function of time. Conclusion Simulating and understanding trajectories for varying initial speeds and angles is essential for modern space missions. From orbital insertions to deep-space escapes, mastering these mechanics is a fundamental part of aerospace engineering. Frequently Asked Questions (FAQ) Q1: Why simulate different angles? Different angles allow payloads to achieve stable orbit, escape, or crash depending on mission needs. Q2: How does energy help classify trajectory type? Total energy being negative, zero, or positive immediately tells whether the motion is elliptical, parabolic, or hyperbolic. Q3: Can air resistance be included? Yes, adding atmospheric drag would make the simulation more realistic but more complex. Q4: Why does velocity decrease after release? Gravitational pull reduces upward velocity; depending on initial speed, the payload may orbit, escape, or fall. Q5: How accurate is Euler's method here? For small enough time steps ( \\(\\Delta t\\) ), it gives reasonably accurate approximations, but better methods exist (e.g., Runge-Kutta 4th order). Visit Colab","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions such as velocity, angle, and altitude. This problem blends principles of orbital mechanics, energy conservation, and numerical simulation. Understanding these trajectories is critical for missions like satellite deployment, reentry modules, or escaping Earth's gravity.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-possible-trajectories","text":"Depending on the initial velocity ( \\(v_0\\) ) and altitude ( \\(h\\) ), a payload can follow different paths: Elliptical Orbit : \\(v_0\\) < escape velocity; payload remains bound to Earth. Parabolic Trajectory : \\(v_0\\) \u2248 escape velocity; payload barely escapes Earth's gravity. Hyperbolic Trajectory : \\(v_0\\) > escape velocity; payload escapes with excess kinetic energy. Suborbital Trajectory : \\(v_0\\) too low for orbit; payload falls back to Earth.","title":"Types of Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#fundamental-equations","text":"Gravitational Force: \\(F = \\frac{GMm}{r^2}\\) Gravitational Potential Energy: \\(U = -\\frac{GMm}{r}\\) Kinetic Energy: \\(K = \\frac{1}{2}mv^2\\) Total Energy (E): \\(E = K + U\\) If \\(E < 0\\) : Elliptical orbit If \\(E = 0\\) : Parabolic trajectory If \\(E > 0\\) : Hyperbolic escape","title":"Fundamental Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants-and-initial-setup","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6371e3 # Radius of Earth (m) altitude = 300e3 # Payload release altitude (m) r0 = R_earth + altitude v_escape = np.sqrt(2 * G * M_earth / r0) print(f\"Escape velocity at {altitude/1000:.0f} km altitude: {v_escape/1000:.2f} km/s\") Escape velocity at 300 km altitude: 10.93 km/s Note: The escape velocity at the release altitude is printed for reference.","title":"Constants and Initial Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-payloads","text":"initial_velocities = [0.7 * v_escape, v_escape, 1.2 * v_escape] labels = ['Elliptical Orbit', 'Parabolic Escape', 'Hyperbolic Escape'] dt = 1 # Time step (s) steps = 15000 fig, ax_traj = plt.subplots(figsize=(8,8)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) x_vals, y_vals = [], [] for _ in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt x_vals.append(pos[0]) y_vals.append(pos[1]) if r < R_earth: break ax_traj.plot(x_vals, y_vals, label=label) # Draw Earth theta = np.linspace(0, 2*np.pi, 100) ax_traj.plot(R_earth*np.cos(theta), R_earth*np.sin(theta), 'k') ax_traj.set_aspect('equal') ax_traj.set_xlim(-2e7, 2e7) ax_traj.set_ylim(-2e7, 2e7) ax_traj.set_xlabel('x (m)') ax_traj.set_ylabel('y (m)') ax_traj.set_title('Payload Trajectories') ax_traj.legend() ax_traj.grid() plt.show() Note: This plot shows how different initial speeds result in different types of trajectories.","title":"Trajectories of Payloads"},{"location":"1%20Physics/2%20Gravity/Problem_3/#energy-vs-time","text":"fig, ax_energy = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) E_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt energy = 0.5 * np.linalg.norm(vel)**2 - G * M_earth / r E_vals.append(energy) t_vals.append(t * dt) if r < R_earth: break ax_energy.plot(t_vals, E_vals, label=label) ax_energy.set_xlabel('Time (s)') ax_energy.set_ylabel('Specific Energy (J/kg)') ax_energy.set_title('Energy vs Time') ax_energy.legend() ax_energy.grid() plt.show() Note: This plot shows how the total specific energy evolves over time for different cases.","title":"Energy vs Time"},{"location":"1%20Physics/2%20Gravity/Problem_3/#velocity-vs-time","text":"fig, ax_velocity = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) v_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt v_vals.append(np.linalg.norm(vel)) t_vals.append(t * dt) if r < R_earth: break ax_velocity.plot(t_vals, v_vals, label=label) ax_velocity.set_xlabel('Time (s)') ax_velocity.set_ylabel('Velocity (m/s)') ax_velocity.set_title('Velocity vs Time') ax_velocity.legend() ax_velocity.grid() plt.show() Note: This plot shows how the payload speed changes with time depending on initial conditions.","title":"Velocity vs Time"},{"location":"1%20Physics/2%20Gravity/Problem_3/#distance-from-earth-vs-time","text":"fig, ax_distance = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) r_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt r_vals.append(r) t_vals.append(t * dt) if r < R_earth: break ax_distance.plot(t_vals, r_vals, label=label) ax_distance.set_xlabel('Time (s)') ax_distance.set_ylabel('Distance from Earth Center (m)') ax_distance.set_title('Distance vs Time') ax_distance.legend() ax_distance.grid() plt.show() Note: This plot shows the distance of the payload from the Earth's center as a function of time.","title":"Distance from Earth vs Time"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"Simulating and understanding trajectories for varying initial speeds and angles is essential for modern space missions. From orbital insertions to deep-space escapes, mastering these mechanics is a fundamental part of aerospace engineering.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q1-why-simulate-different-angles","text":"Different angles allow payloads to achieve stable orbit, escape, or crash depending on mission needs.","title":"Q1: Why simulate different angles?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q2-how-does-energy-help-classify-trajectory-type","text":"Total energy being negative, zero, or positive immediately tells whether the motion is elliptical, parabolic, or hyperbolic.","title":"Q2: How does energy help classify trajectory type?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q3-can-air-resistance-be-included","text":"Yes, adding atmospheric drag would make the simulation more realistic but more complex.","title":"Q3: Can air resistance be included?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q4-why-does-velocity-decrease-after-release","text":"Gravitational pull reduces upward velocity; depending on initial speed, the payload may orbit, escape, or fall.","title":"Q4: Why does velocity decrease after release?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q5-how-accurate-is-eulers-method-here","text":"For small enough time steps ( \\(\\Delta t\\) ), it gives reasonably accurate approximations, but better methods exist (e.g., Runge-Kutta 4th order). Visit Colab","title":"Q5: How accurate is Euler's method here?"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 solution is ....","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"solution is ....","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}